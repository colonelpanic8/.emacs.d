* About
This README is a literate commentary on my emacs configuration, but it also serves as the README for my dotfiles.
* General
** Lexical Binding
This makes it so that the file that is produced from tangling this file uses lexical scoping
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC
** User Info
#+BEGIN_SRC emacs-lisp
  (setq user-full-name
        (replace-regexp-in-string "\n$" "" (shell-command-to-string
                                            "git config --get user.name")))
  (setq user-mail-address
        (replace-regexp-in-string "\n$" "" (shell-command-to-string
                                            "git config --get user.email")))
#+END_SRC
** Custom Files
It's annoying to have emacs randomly add stuff to your init.el whenever you customize a variable. By setting a custom file other than init.el that is ignored in git, random commits with nothing but variable settings are avoided.

custom-before.el is loaded before the rest of init.el, while custom-after.el is loaded afterwards. this-machine.el has customizations that should only apply to the current machine. custom-before and custom-after are not version controlled in the dotfiles repo but they are shared across machines elsewhere.
#+BEGIN_SRC emacs-lisp
  (defvar machine-custom "~/.emacs.d/this-machine.el")
  (defvar custom-after-file "~/.emacs.d/custom-after.el")
  (setq custom-file "~/.emacs.d/custom-before.el")
  (when (file-exists-p custom-file) (load custom-file))
  (when (file-exists-p machine-custom) (load machine-custom))
#+END_SRC
** Benchmarking
This appears here so that it can accurately benchmark as much of startup as possible.
#+BEGIN_SRC emacs-lisp
  (defvar imalison:do-benchmark)
  (when (and (boundp 'imalison:do-benchmark) imalison:do-benchmark)
    (use-package benchmark-init))
#+END_SRC
** GUI Disables
Death to any gui elements in emacs! Do this EARLY so that emacs doesn't redisplay in a way that is visually unpleasant on startup a bunch of times.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC
Tooltips are annoying:
#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tooltip-mode) (tooltip-mode -1) (setq tooltip-use-echo-area t))'
#+END_SRC
** Byte-Compiler
These definitions silence the byte-compiler
#+BEGIN_SRC emacs-lisp
  (defvar ido-cur-item nil)
  (defvar ido-default-item nil)
  (defvar ido-context-switch-command nil)
  (defvar ido-cur-list nil)
  (defvar inherit-input-method nil)
  (defvar grep-find-ignored-files nil)
  (defvar grep-find-ignored-directories nil)
  (defvar tls-checktrust nil)
  (defvar tls-program nil)
#+END_SRC
** Security
#+BEGIN_SRC emacs-lisp
  (defvar imalison:secure t)

  (defun imalison:use-https-and-tls ()
    (setq tls-checktrust t)
    (let ((trustfile
           (replace-regexp-in-string
            "\\\\" "/"
            (replace-regexp-in-string
             "\n" ""
             (shell-command-to-string "python -m certifi")))))
      (setq tls-program
            (list
             (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                     (if (eq window-system 'w32) ".exe" "") trustfile)))))

  (defun imalison:test-security ()
    (interactive)
    (let ((bad-hosts
         (loop for bad
               in `("https://wrong.host.badssl.com/"
                    "https://self-signed.badssl.com/")
               if (condition-case _e
                      (url-retrieve
                       bad (lambda (_retrieved) t))
                    (error nil))
               collect bad)))
    (if bad-hosts
        (error (format "tls misconfigured; retrieved %s ok"
                       bad-hosts))
      (url-retrieve "https://badssl.com"
                    (lambda (_retrieved) t)))))

  (when imalison:secure (imalison:use-https-and-tls))
#+END_SRC
** ELPA Archive Setup
#+BEGIN_SRC emacs-lisp -n -r
  (require 'package)

  (defun imalison:build-archive-uri (uri protocol)
    (unless protocol (setq protocol (if imalison:secure "https" "http")))
    (format "%s://%s" protocol uri))

  (defvar imalison:package-archive-triples
    '(("elpa" "tromey.com/elpa/" "http")
      ;; ("marmalade" "marmalade-repo.org/packages/")             (ref:marmalade)
      ("org" "orgmode.org/elpa/" "http")                          (ref:org setup)
      ("melpa" "melpa.org/packages/" nil)))

  (defun imalison:add-package-archive (archive-name archive-uri)
    (add-to-list 'package-archives
                 `(,archive-name . ,archive-uri) t))

  (cl-loop for package-triple in imalison:package-archive-triples
           do (cl-destructuring-bind (archive-name archive-uri protocol) package-triple
                (imalison:add-package-archive
                 archive-name (imalison:build-archive-uri archive-uri protocol))))
#+END_SRC
[[(org setup)][The org archive]] does not support https, so we set http as the protocol explicitly.
I've decided to stop using [[(marmalade)][Marmalade]] completely
** Bootstrap Package Loading
Its a shame that everyone has to have some version of this function in their init.el. I use use-package's own mechanism for ensuring packages are installed so my version of ~ensure-packages-installed~ is really only used to download use-package itself.
#+BEGIN_SRC emacs-lisp
  (defun ensure-packages-installed (packages)
    (unless package-archive-contents
      (package-refresh-contents))
    (mapcar
     (lambda (package)
       (if (package-installed-p package)
           package
         (progn (message (format "Installing package %s." package))
                (package-install package))))
     packages))
#+END_SRC
Ensure that use-package is installed.
#+BEGIN_SRC emacs-lisp
  (package-initialize t)
  (ensure-packages-installed '(use-package))
#+END_SRC
use-package is only needed at compile time.
#+BEGIN_SRC emacs-lisp
  (eval-when-compile (require 'use-package))
#+END_SRC
Ensure by default since most of the package for which I use use-package need to be downloaded. ensure can be disabled explicitly with a ~:ensure nil~.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC
** Sane Defaults
#+BEGIN_SRC emacs-lisp -n -r
  (global-auto-revert-mode)
  (show-paren-mode 1)
  (setq reb-re-syntax 'string)
  (setq ad-redefinition-action 'accept)              (ref:ad-redefinition-action)
#+END_SRC
[[(ad-redefinition-action)][This]] is set because [[(y-or-n-p-only)][this alias]] causes annoying messaging at startup.
** Line Numbers
#+BEGIN_SRC emacs-lisp
  (line-number-mode t)
  (column-number-mode t)
  (global-linum-mode t)
#+END_SRC
** Backups
*** Put them all in one directory
#+BEGIN_SRC emacs-lisp
  (defconst emacs-tmp-dir
    (format "%s/%s%s/" temporary-file-directory "emacs" (user-uid)))
  (setq backup-directory-alist `((".*" . ,emacs-tmp-dir)))
  (setq auto-save-file-name-transforms `((".*" ,emacs-tmp-dir t)))
  (setq auto-save-list-file-prefix emacs-tmp-dir)
#+END_SRC
*** Completely disable backups
#+BEGIN_SRC emacs-lisp
  (setq backup-inhibited t)
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC
** Prompts
*** No popup frames
#+BEGIN_SRC emacs-lisp
  (setq ns-pop-up-frames nil)
  (setq pop-up-frames nil)
#+END_SRC
*** boolean (yes-or-no)
#+BEGIN_SRC emacs-lisp -n -r
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))

  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))

  (defalias 'yes-or-no-p 'y-or-n-p)                           (ref:y-or-n-p-only)
#+END_SRC
*** No dialog boxes
#+BEGIN_SRC emacs-lisp
  (setq use-dialog-box nil)
#+END_SRC
** Splitting
#+BEGIN_SRC emacs-lisp
  (defun split-horizontally-for-temp-buffers () (split-window-horizontally))
  (add-hook 'temp-buffer-setup-hook 'split-horizontally-for-temp-buffers)
  (setq split-height-threshold nil)
  (setq split-width-threshold 160)
#+END_SRC
** Fill Setup
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC
** Encoding
UTF-8 everywhere
#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
  (setq locale-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (unless (eq system-type 'windows-nt)
    (set-selection-coding-system 'utf-8))
  (prefer-coding-system 'utf-8)
#+END_SRC
Disable CJK coding/encoding (Chinese/Japanese/Korean characters)
#+BEGIN_SRC emacs-lisp
  (setq utf-translate-cjk-mode nil)
#+END_SRC
** Visible Bell
This is set to true to disable the annoying audible bell that plays whenever there is an error.
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC
** Misc
#+BEGIN_SRC emacs-lisp
  (defvar iedit-toggle-key-default nil)
  (put 'set-goal-column 'disabled nil)
  (auto-fill-mode -1)
  (setq indent-tabs-mode nil)

  ;; No hsplits. EVER.

  (setq confirm-nonexistent-file-or-buffer nil)

  ;; No prompt for killing a buffer with processes attached.
  (setq kill-buffer-query-functions
    (remq 'process-kill-buffer-query-function
          kill-buffer-query-functions))

  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)

  ;; This makes it so that emacs --daemon puts its files in ~/.emacs.d/server
  ;; (setq server-use-tcp t)

  ;; Display line and column numbers in mode line.


  ;; Make buffer names unique.
  (setq uniquify-buffer-name-style 'forward)

  ;; We want closures
  (setq lexical-binding t)

  (setq fill-column 80)

  ;; Don't disable commands...
  (setq disabled-command-function nil)

  ;; Make forward word understand camel and snake case.
  (setq c-subword-mode t)
  (global-subword-mode)

  ;; Preserve pastes from OS when saving a new item to the kill
  ;; ring. Why wouldn't this be enabled by default?

  (setq-default cursor-type 'box)
  (setq-default cursor-in-non-selected-windows 'bar)

  (when nil ;; Causing too many annoying issues
      (add-hook 'after-init-hook '(lambda () (setq debug-on-error t))))

  ;; Make mouse scrolling less jumpy.
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))

  (setq display-time-default-load-average nil)
  (setq display-time-interval 1)
  (setq display-time-format "%a, %b %d, %T ")
  (display-time-mode 1)

   ;; the only sane option...

  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Disable this per major mode or maybe using file size if it causes
  ;; performance issues?
  (setq imenu-auto-rescan t)
  (setq imenu-max-item-length 300)

  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)

  (setq echo-keystrokes 0.25)

  (setq initial-scratch-message "")

  (setq checkdoc-force-docstrings-flag nil
        checkdoc-arguments-in-order-flag nil)

  ;; text mode stuff:
  (remove-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
  (setq sentence-end-double-space nil)

  ;; y and n instead of yes and no
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (setq-default c-basic-offset 4
                  tab-width 4
                  indent-tabs-mode t)

  (add-hook 'prog-mode-hook (lambda () (auto-fill-mode -1)))
  ;; (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  ;; (add-hook 'prog-mode-hook (lambda () (highlight-lines-matching-regexp
  ;;                                  ".\\{81\\}" 'hi-blue)))
#+END_SRC
* Functions
** Required Packages
The packages in this section provide no functionality on their own, but provide support for writing custom elisp
*** s
#+BEGIN_SRC emacs-lisp
  (use-package s :demand t)
#+END_SRC
*** gh
#+BEGIN_SRC emacs-lisp
  (use-package gh
    :ensure nil
    :defer t
    :load-path "~/Projects/gh.el")
#+END_SRC
*** shut-up
#+BEGIN_SRC emacs-lisp
  (use-package shut-up
    :config
    (defun imalison:shut-up-around (function &rest args)
      (shut-up (apply function args))))
#+END_SRC
*** pcache
#+BEGIN_SRC emacs-lisp
  (use-package pcache
    :demand t)
#+END_SRC
*** parse-csv
#+BEGIN_SRC emacs-lisp
  (use-package parse-csv
    :demand t)
#+END_SRC
** Macros
*** Emacs Version Predicate
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:emacs-version-predicate (major-version minor-version)
    `(lambda ()
       (or (> emacs-major-version ,major-version)
           (and (>= emacs-major-version ,major-version)
                (>= emacs-minor-version ,minor-version)))))
  (defun imalison:check-emacs-version (major-version minor-version)
    (funcall (imalison:emacs-version-predicate major-version minor-version)))
#+END_SRC
*** Compose Functions
**** Arbitrary arguments at every step
#+BEGIN_SRC emacs-lisp
  (defun imalison:make-list (thing)
    (if (listp thing)
        thing
      (list thing)))

  (defmacro imalison:compose (&rest funcs)
    "Build a new function with NAME that is the composition of FUNCS."
    `(lambda (&rest args)
       (imalison:compose-helper ,funcs)))

  (defmacro imalison:compose-helper (funcs)
    "Builds funcalls of FUNCS applied to the arg."
    (if (equal (length funcs) 0)
        (quote args)
      `(apply ,(car funcs)
              (imalison:make-list (imalison:compose-helper ,(cdr funcs))))))
#+END_SRC
**** Simpler Unary version
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:compose-unary (&rest funcs)
    "Build a new function with NAME that is the composition of FUNCS."
    `(lambda (arg)
       (imalison:compose-helper-unary ,funcs)))

  (defmacro imalison:compose-helper-unary (funcs)
    "Builds funcalls of FUNCS applied to the arg."
    (if (equal (length funcs) 0)
        'arg
      `(funcall ,(car funcs) (imalison:compose-helper-unary ,(cdr funcs)))))
#+END_SRC
**** A Version Supporting Macros
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:compose-2 (arguments &rest funcs)
    (when (numberp arguments)
      (setq arguments
            (cl-loop for i from 97 to (+ arguments 96)
                     collect (intern (char-to-string i)))))
    `(imalison:compose-2-argspec ,arguments ,arguments ,@funcs))

  (defmacro imalison:compose-2-argspec
      (arguments call-arguments &rest funcs)
    "Build a new function with NAME that is the composition of FUNCS."
    `(lambda ,arguments
       (imalison:compose-2-helper ,funcs ,call-arguments)))

  (defmacro imalison:compose-2-helper (funcs arguments)
    "Builds funcalls of FUNCS applied to the arg."
    (if (equal (length funcs) 1)
        `(,(car funcs) ,@arguments)
      `(,(car funcs)
        (imalison:compose-2-helper ,(cdr funcs) ,arguments))))
#+END_SRC
*** Prefix Alternatives
Prefix alternatives is a macro that builds a function that selects one of a collection of functions that are provided to the macro based on the value of the prefix argument.
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:prefix-alternatives (name &rest alternatives)
    `(defun ,name (arg)
       (interactive "p")
       (setq function
             (cond
              ,@(progn
                  (let ((last-power 1))
                    (cl-loop for alternative in alternatives
                             collect `((eq arg ,last-power) (quote ,alternative))
                             do (setq last-power (* last-power 4)))))))
       (setq function (or function)) ; Set a default value for function
       (setq current-prefix-arg nil)
       (call-interactively function)))
#+END_SRC
*** Named Build
imalison:named-build is a way to invoke a macro in such a way that the lambda that it produces is given a name.
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:named-build (name builder &rest args)
    `(defalias (quote ,name) (,builder ,@args)))
  (put 'imalison:named-build 'lisp-indent-function 1)

  (defmacro imalison:named-builder-builder (named-builder-name builder-name)
    `(defmacro ,named-builder-name (function-name &rest args)
       (cons ,builder-name args)))
#+END_SRC
*** Use Package Wrapper With Local Load Path Support
#+BEGIN_SRC emacs-lisp
  (put 'imalison:use-package 'lisp-indent-function 1)

  (defmacro imalison:use-package* (package target-directory &rest forms)
    (let* ((target-exists (file-exists-p target-directory))
           (additional-forms
            (when target-exists
              (list
               :load-path target-directory
               :ensure nil))))
      `(use-package ,package
         ,@additional-forms ,@forms)))

  (defmacro imalison:use-package (package &rest forms)
    (let ((target-directory
           (concat (file-name-as-directory (if (boundp 'imalison:projects-directory)
                                               imalison:projects-directory
                                             "~/Projects"))
                   (symbol-name package))))
      `(imalison:use-package* ,package ,target-directory ,@forms)))


#+END_SRC

** Join paths together as with os.path.join in python
#+BEGIN_SRC emacs-lisp
  (defun imalison:join-paths (root &rest dirs)
    (let ((result root))
      (cl-loop for dir in dirs do
               (setq result (concat (file-name-as-directory result) dir)))
      result))
#+END_SRC
** Variables
#+BEGIN_SRC emacs-lisp
  (defvar imalison:projects-directory
    (imalison:join-paths "~" "Projects"))

  (defvar imalison:gpg-key)
#+END_SRC
** Flatten Imenu Indexes
I like my imenu indexes flat so I don't have to press enter multiple times to find what I'm looking for. The functions that follow allow me to get this behavior out of functions that provide a nested imenu index.
#+BEGIN_SRC emacs-lisp
  (defun imalison:imenu-prefix-flattened (index)
    (let ((flattened (imalison:flatten-imenu-index (cdr index))))
      (cl-loop for sub-item in flattened
               collect
               `(,(concat (car index) "." (car sub-item)) . ,(cdr sub-item)))))

  (defun imalison:flatten-imenu-index (index)
    (let ((cdr-is-index (listp (cdr index))))
      (cond ((not (stringp (car index))) (cl-mapcan
                                          #'imalison:flatten-imenu-index index))
            (cdr-is-index (imalison:imenu-prefix-flattened index))
            (t (list index)))))

  (defun imalison:make-imenu-index-flat ()
    (let ((original-imenu-function imenu-create-index-function))
      (setq imenu-create-index-function
            (lambda ()
              (imalison:flatten-imenu-index
               (funcall original-imenu-function))))))
#+END_SRC
By advising ~imenu--make-index-alist~ with ~imalison:flatten-imenu-index~ we make it so that imenu indexes are always flattened. This is still experimental, so copy to your own dotfiles with caution.
#+BEGIN_SRC emacs-lisp
  (defun imalison:flatten-imenu-index-with-function
      (index-build-function &rest args)
    (imalison:flatten-imenu-index (apply index-build-function args)))

  (advice-add 'imenu--make-index-alist
              :around 'imalison:flatten-imenu-index-with-function)
#+END_SRC

** Add files to org-agenda-files
#+BEGIN_SRC emacs-lisp
  (defun imalison:add-to-org-agenda-files (incoming-files)
    (setq org-agenda-files
          (delete-dups
           (cl-loop for filepath in (append org-agenda-files incoming-files)
                    when (and filepath (file-exists-p (file-truename filepath)))
                    collect (file-truename filepath)))))
#+END_SRC
** Get file string
#+BEGIN_SRC emacs-lisp
  (defun imalison:get-string-from-file (file-path)
    "Return file-path's file content."
    (with-temp-buffer
      (insert-file-contents file-path)
      (buffer-string)))
#+END_SRC
** Get current location
#+BEGIN_SRC emacs-lisp
  (defun imalison:get-lat-long ()
    (condition-case _ex
        (mapcar 'string-to-number (s-split "," (s-trim (shell-command-to-string
                                                        "whereami"))))
      (error (list 37.7879312624533 -122.402388853402))))
#+END_SRC
** Haversine distance
#+BEGIN_SRC emacs-lisp
  (defun imalison:sin2 (p)
    (let ((sin-p (sin p)))
      (* sin-p sin-p) ))

  (defun imalison:haversine-distance
      (left-lat-long right-lat-long &optional radius)
    ;; Default to earth radius in km
    (unless radius (setq radius 6378.1))
    (interactive)
    (cl-destructuring-bind (left-lat left-long) left-lat-long
      (cl-destructuring-bind (right-lat right-long) right-lat-long
        (let ((l1 (degrees-to-radians left-lat))
              (f1 (degrees-to-radians left-long))
              (l2 (degrees-to-radians right-lat))
              (f2 (degrees-to-radians right-long)) )
          (* 2 radius
             (asin
              (sqrt
               (+ (imalison:sin2 (/ (- f2 f1) 2))
                  (* (cos f2) (cos f1) (imalison:sin2 (/ (- l2 l1) 2))) ))))))))
#+END_SRC
** Muni
Create cache structure containing stop information
#+BEGIN_SRC emacs-lisp
  (defclass imalison:muni-stop ()
    ((id :initarg :id)
     (name :initarg :name)
     (lat :initarg :lat)
     (long :initarg :long)))

  (defmethod imalison:muni-stop-get-lat-long ((stop imalison:muni-stop))
    (list (oref stop :lat) (oref stop :long)))

  (defvar imalison:muni-stop-cache (pcache-repository "imalison-muni-stop"))

  (defun imalison:muni-get-gtfs-stops (&optional filepath)
    (unless filepath
      (setq filepath
            (concat (file-name-directory load-file-name) "stops.txt")))
    (let ((data (imalison:get-string-from-file filepath)))
      (parse-csv-string-rows data ?\, ?\" "\n")))

  (defun imalison:build-muni-stop-from-gtfs-stop (gtfs-stop)
    (when (stringp (nth 3 gtfs-stop))
      (make-instance imalison:muni-stop
                     :id (nth 0 gtfs-stop)
                     :name (nth 1 gtfs-stop)
                     :lat (string-to-number (nth 3 gtfs-stop))
                     :long (string-to-number (nth 4 gtfs-stop)))))

  (defun imalison:muni-populate-stop-cache (&optional filepath)
    (cl-loop for gtfs-stop in (imalison:muni-get-gtfs-stops filepath)
             do (let ((muni-stop
                       (imalison:build-muni-stop-from-gtfs-stop gtfs-stop)))
                  (when muni-stop
                    (pcache-put imalison:muni-stop-cache
                                (intern (oref muni-stop :id)) muni-stop)))))

  (defun imalison:muni-stop-from-id (stop-or-id)
    (if (imalison:muni-stop-p stop) stop-or-id
      (pcache-get imalison:muni-stop-cache stop-or-id)))
#+END_SRC
Get route information
#+BEGIN_SRC emacs-lisp
  (defun imalison:muni-get-route-ids (route-name &optional direction)
    (delete-dups
     (mapcar (imalison:compose-2 1 intern car)
             (s-match-strings-all
              "^\\([[:digit:]]\\{1,10\\}\\)"
              (shell-command-to-string
               (format "muni show %s %s -v" route-name (or direction "")))))))
#+END_SRC

Stop selection functions
#+BEGIN_SRC emacs-lisp
  (cl-defun imalison:closest-stop (stops &key location)
    (unless location (setq location (imalison:get-lat-long)))
    (let (minimizing (minimum 1.0e+INF))
      (cl-loop for stop in stops
               do (let* ((actual-stop (imalison:muni-stop-from-id stop))
                         (stop-lat-long (imalison:muni-stop-get-lat-long actual-stop))
                         (this-dist (imalison:haversine-distance location stop-lat-long)))
                 (when (< this-dist minimum)
                   (setq minimizing actual-stop
                         minimum this-dist))))
      minimizing))

  (cl-defun imalison:muni-stops-within (stops &key (radius .25) current-location)
    (unless current-location (setq current-location (imalison:get-lat-long)))
    (cl-loop for stop in stops
             with actual-stop = nil
             when (let ((stop-lat-long (imalison:muni-stop-get-lat-long actual-stop)))
                    (setq actual-stop (imalison:muni-stop-from-id stop))
                    (< (imalison:haversine-distance current-location stop-lat-long) radius))
             collect actual-stop))
#+END_SRC

A function that shells out to get upcoming trains
#+BEGIN_SRC emacs-lisp
  (defun imalison:muni-predict (route direction stop)
    (s-trim
     (shell-command-to-string
      (format "muni predict %s %s %s" route direction stop))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun imalison:parse-muni-info (info-string)
    (when (string-match "\\([[:digit:]]\\{1,3\\}\\) *minutes" info-string)
      (match-string-no-properties 1 info-string)))
#+END_SRC

A cached version of the muni functions for use in spaceline and elsewhere.
#+BEGIN_SRC emacs-lisp
  (defvar imalison:muni-cache (pcache-repository "imalison-muni"))
  (defvar imalison:current-location-ttl 10)
  (defvar imalison:muni-arrival-ttl 25)

  (defun imalison:get-cached-muni-time ()
    (let ((current-location (pcache-get imalison:muni-cache 'current-location))
          (arrival-time (pcache-get imalison:muni-cache 'arrival-time)))
      (unless arrival-time
        (unless current-location
          (setq current-location (imalison:get-lat-long))
          (pcache-put imalison:muni-cache 'current-location current-location
                      imalison:current-location-ttl))
        (setq arrival-time (imalison:parse-muni-info
                            (imalison:get-closest-muni-info current-location)))
        (pcache-put imalison:muni-cache 'arrival-time arrival-time
                    imalison:muni-arrival-ttl))
      arrival-time))
#+END_SRC
** Font Size
This was taken from [[http://emacs.stackexchange.com/questions/7583/transiently-adjust-text-size-in-mode-line-and-minibuffer][here]]. It is primarily invoked from a hydra defined below. It would be cool if it got the default font size from whatever the default font was but it does not currently do that.
#+BEGIN_SRC emacs-lisp
  (setq imalison:default-font-size-pt 14)

  (defun imalison:font-size-adj (&optional arg)
    "The default C-x C-0/-/= bindings do an excellent job of font resizing.
  They, though, do not change the font sizes for the text outside the buffer,
  example in mode-line. Below function changes the font size in those areas too.

  M-<NUM> M-x imalison:font-size-adj increases font size by NUM points if NUM is +ve,
                                 decreases font size by NUM points if NUM is -ve
                                 resets    font size if NUM is 0."
    (interactive "p")
    (if (= arg 0)
        (setq font-size-pt imalison:default-font-size-pt)
      (setq font-size-pt (+ font-size-pt arg)))
    ;; The internal font size value is 10x the font size in points unit.
    ;; So a 10pt font size is equal to 100 in internal font size value.
    (set-face-attribute 'default nil :height (* font-size-pt 10)))

  (defun imalison:font-size-incr ()  (interactive) (imalison:font-size-adj +1))
  (defun imalison:font-size-decr ()  (interactive) (imalison:font-size-adj -1))
  (defun imalison:font-size-reset () (interactive) (imalison:font-size-adj 0))
#+END_SRC
** Message Result Builder
This macro is useful when writing emacs-lisp. It creates a new interactive command that shows you the result of evaluating a function, with optionally provided arguments.
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:message-result-builder (new-function-name function-to-call &rest args)
    `(defun ,new-function-name ()
       (interactive)
       (message "%s" (apply (quote ,function-to-call) (list ,@args)))))
#+END_SRC
This interactive functions allows the user the select a function to invoke using a freshly minted imalison:message-result-builder
#+BEGIN_SRC emacs-lisp
  (defun imalison:message-result-builder-runtime (function &rest args)
    (lambda ()
      (interactive)
      (message "%s" (apply function-to-call args))))

  (defun imalison:message-function-result (function)
    (interactive (find-function-read))
    (message "%s" (funcall function)))
#+END_SRC
** Make interactive
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:make-interactive (function)
    `(lambda (&rest args)
       (interactive)
       (apply ,function args)))
#+END_SRC

** Custom shell command on region
#+BEGIN_SRC emacs-lisp
  (defun imalison:copy-shell-command-on-region (start end command)
    (interactive (list (region-beginning) (region-end)
                       (read-shell-command "Shell command on region: ")))
    (let ((original-buffer (current-buffer)))
      (with-temp-buffer
        (let ((temp-buffer (current-buffer)))
          (with-current-buffer original-buffer
            (shell-command-on-region start end command temp-buffer))
          (kill-ring-save (point-max) (point-min))))))

  (defun imalison:shell-command-on-region-replace (start end command)
    (interactive (list (region-beginning) (region-end)
                       (read-shell-command "Shell command on region: ")))
    (shell-command-on-region start end command nil t))

  (imalison:prefix-alternatives imalison:copy-shell-command-on-region
                                imalison:shell-command-on-region-replace)
#+END_SRC
** Copy string functions
A macro for composing functions together to build an interactive command to copy a string to the kill ring.
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:compose-copy-builder (name &rest funcs)
    `(imalison:named-build ,name
       imalison:make-interactive
       (imalison:compose 'kill-new ,@funcs)))
#+END_SRC

*** Copy portions of the buffer file name
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:copy-buffer-file-path-builder (&rest args)
    `(imalison:compose-copy-builder ,@args 'buffer-file-name))

  (imalison:copy-buffer-file-path-builder imalison:copy-buffer-file-path-full)
  (imalison:copy-buffer-file-path-builder imalison:copy-buffer-file-name
                                          'file-name-nondirectory)
  (imalison:copy-buffer-file-path-builder imalison:copy-buffer-file-path
                                          'projectile-make-relative-to-root
                                          'list)
#+END_SRC
*** Copy the current branch using magit
#+BEGIN_SRC emacs-lisp
  (imalison:compose-copy-builder imalison:copy-current-git-branch
                                 'magit-get-current-branch)
#+END_SRC
** Advice Add Around Builder
For composing functions with an apply so that they can be used with the ~:around~ keyword of advice-add
#+BEGIN_SRC emacs-lisp
  (defmacro imalison:compose-around-builder (&rest functions)
    `(imalison:compose ,@functions 'apply))
#+END_SRC
** Other
#+BEGIN_SRC emacs-lisp
  (defun imalison:join-paths (&rest paths)
    (substring (mapconcat 'file-name-as-directory paths nil) 0 -1))

  (defun random-choice (choices)
    (nth (random (length choices)) choices))

  (defun display-prefix (arg)
    "Display the value of the raw prefix arg."
    (interactive "p")
    (message "%s" arg))

  (defmacro imalison:let-advise-around (name &rest forms)
    `(defun ,name (orig-func &rest args)
       (let ,forms
         (apply orig-func args))))

  (defmacro imalison:dynamic-let-advise-around (name &rest getters)
    `(defun ,name (orig-func &rest args)
       (let ,(cl-loop for pair in getters
                      collect `(,(car pair) (funcall (quote ,(cadr pair)))))
         (apply orig-func args))))

  (defun imalison:uuid ()
    (interactive)
    (s-replace "\n" "" (shell-command-to-string "uuid")))

  (defun imalison:disable-linum-mode ()
    (linum-mode 0))

  (defun imalison:disable-smartparens-mode ()
    (smartparens-mode 0))

  (defun imalison:insert-uuid ()
    (interactive)
    (insert (imalison:uuid)))

  (defun imalison:compare-int-list (a b)
    (when (and a b)
      (cond ((> (car a) (car b)) 1)
            ((< (car a) (car b)) -1)
            (t (imalison:compare-int-list (cdr a) (cdr b))))))

  (defun get-date-created-from-agenda-entry (agenda-entry)
    (org-time-string-to-time
     (org-entry-get (get-text-property 1 'org-marker agenda-entry) "CREATED")))

  (defmacro defvar-setq (name value)
    (if (boundp name)
        `(setq ,name ,value)
      `(defvar ,name ,value)))

  (defun eval-region-or-last-sexp ()
    (interactive)
    (if (region-active-p) (call-interactively 'eval-region)
      (call-interactively 'eval-last-sexp)))

  (defun undo-redo (&optional arg)
    (interactive "P")
    (if arg (undo-tree-redo) (undo-tree-undo)))

  (defun up-list-region ()
    (interactive)
    (up-list) (set-mark-command nil) (backward-sexp))

  (defun up-list-back ()
    (interactive)
    (up-list) (backward-sexp))

  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))

  (defun fill-or-unfill-paragraph (&optional unfill region)
    "Fill paragraph (or REGION). With the prefix argument UNFILL,
  unfill it instead."
      (interactive (progn
                     (barf-if-buffer-read-only)
                     (list (if current-prefix-arg 'unfill) t)))
      (let ((fill-column (if unfill (point-max) fill-column)))
        (fill-paragraph nil region)))

  (defun frame-exists ()
    (cl-find-if
     (lambda (frame)
       (assoc 'display (frame-parameters frame))) (frame-list)))

  (defun make-frame-if-none-exists ()
    (let* ((existing-frame (frame-exists)))
      (if existing-frame
          existing-frame
        (make-frame-on-display (getenv "DISPLAY")))))

  (defun make-frame-if-none-exists-and-focus ()
    (make-frame-visible (select-frame (make-frame-if-none-exists))))

  (defun open-pdf ()
    (interactive)
    (let ( (pdf-file (replace-regexp-in-string
                      "\.tex$" ".pdf" buffer-file-name)))
      (shell-command (concat "open " pdf-file))))

  (defun eval-and-replace ()
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defun notification-center (title message)
    (cl-flet ((encfn (s) (encode-coding-string s (keyboard-coding-system))))
      (shell-command
       (format "osascript -e 'display notification \"%s\" with title \"%s\"'"
               (encfn message) (encfn title)))))

  (defun growl-notify (title message)
    (shell-command (format "grownotify -t %s -m %s" title message)))

  (defun notify-send (title message)
    (shell-command (format "notify-send -u critical %s %s" title message)))

  (defvar notify-function
    (cond ((eq system-type 'darwin) 'notification-center)
          ((eq system-type 'gnu/linux) 'notify-send)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (imalison:prefix-alternatives imalison:mark-ring helm-mark-ring helm-global-mark-ring)
#+END_SRC
* Macros
** For editing literate config
*** extract-current-sexp-to-src-block
This keyboard macro extracts the current sexp to an emacs-lisp source block of its own
#+BEGIN_SRC emacs-lisp
  (fset 'extract-current-sexp-to-src-block
     [?\C-a return ?\C-p ?# ?+ ?E ?N ?D ?_ ?S ?R ?C return ?# ?+ ?B ?E ?G ?I ?N ?_ ?S ?R ?C ?  ?e ?m ?a ?c ?s ?- ?l ?i ?s ?p ?\C-a ?\C-p ?\C-  ?\C-n ?\C-e ?\M-w ?\C-n ?\C-a ?\C-\M-f return ?\C-y])

#+END_SRC
*** name-source-block-for-use-package-name
#+BEGIN_SRC emacs-lisp
  (fset 'name-source-block-for-use-package-name
     [?\C-c ?\' ?\M-< ?\C-s ?u ?s ?e ?- ?p ?a ?c ?k return ?\C-\M-f ?\C-f ?\C-  ?\C-\M-f ?\M-w ?\C-c ?\' ?\C-r ?B ?E ?G ?I ?N return ?\C-a ?\C-p ?\C-e return ?* ?  ?\C-y])
#+END_SRC
*** extract-and-name-use-package-block
#+BEGIN_SRC emacs-lisp
  (fset 'extract-and-name-use-package-block
     [?\C-a return ?\C-p ?# ?+ ?E ?N ?D ?_ ?S ?R ?C return ?# ?+ ?B ?E ?G ?I ?N ?_ ?S ?R ?C ?  ?e ?m ?a ?c ?s ?- ?l ?i ?s ?p ?\C-a ?\C-p ?\C-  ?\C-n ?\C-e ?\M-w ?\C-n ?\C-a ?\C-\M-f return ?\C-y ?\C-p ?\C-p ?\C-c ?\' ?\M-< ?\C-s ?u ?s ?e ?- ?p ?a ?c ?k return ?\C-\M-f ?\C-f ?\C-  ?\C-\M-f ?\M-w ?\C-c ?\' ?\C-r ?B ?E ?G ?I ?N return ?\C-a ?\C-p ?\C-e return ?* ?  ?\C-y])
#+END_SRC
* Packages
** Emacs
*** exec-path-from-shell
Sets environment variables by starting a shell 
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
      :config
      (progn
        (setq exec-path-from-shell-check-startup-files t)
        (add-to-list 'exec-path-from-shell-variables "GOPATH")
        (exec-path-from-shell-initialize)))
#+END_SRC
*** paradox
#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :defer 10
    :commands (paradox-upgrade-packages paradox-list-packages)
    :config
    (progn
      (require 'gh)
      (setq paradox-execute-asynchronously t
            paradox-github-token (gh-auth-get-oauth-token))))
#+END_SRC
*** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :preface
    (defvar imalison:packages-to-diminish
      '(auto-revert-mode smartparens-mode eldoc-mode tern-mode js2-refactor-mode))
    :config
    (progn
      (cl-loop for package in imalison:packages-to-diminish
               do (diminish package))
      (eval-after-load 'subword '(diminish 'subword-mode))
      (eval-after-load 'simple '(diminish 'visual-line-mode))))
#+END_SRC
*** edit-server
#+BEGIN_SRC emacs-lisp
  (use-package edit-server
    :commands edit-server-start
    :defer 1
    :config
    (progn
      (edit-server-start)
      (setq edit-server-new-frame nil)))
#+END_SRC
*** load-dir
#+BEGIN_SRC emacs-lisp
  (use-package load-dir
    :config
    (progn
      (setq load-dir-debug nil)
      (add-to-list 'load-dirs "~/.emacs.d/load.d")
      (defvar site-lisp "/usr/share/emacs24/site-lisp/")
      (when (file-exists-p site-lisp) (add-to-list 'load-dirs site-lisp))))
#+END_SRC
*** server
#+BEGIN_SRC emacs-lisp
  (use-package server
    :config
    (progn
      (unless (server-running-p) (server-start))))
#+END_SRC
*** list-environment
#+BEGIN_SRC emacs-lisp
  (use-package list-environment)
#+END_SRC
*** bug-hunter
#+BEGIN_SRC emacs-lisp
  (use-package bug-hunter)
#+END_SRC
*** shackle
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :disabled t
    :config
    (progn
      (diminish 'shackle-mode)
      (when nil                           ; disabled for now
        (shackle-mode))
      (setq shackle-inhibit-window-quit-on-same-windows t)
      (setq shackle-default-rule '(:same t))))
#+END_SRC

*** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :bind ("C-c b" . beacon-blink)
    :config
    (beacon-mode 1))
#+END_SRC
*** discover-my-major
#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major)
#+END_SRC
** Keybindings
*** bind-key
#+BEGIN_SRC emacs-lisp
  (use-package bind-key)
#+END_SRC
*** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (progn
      (setq which-key-idle-delay .50)
      (diminish 'which-key-mode)
      (which-key-mode)))
#+END_SRC
*** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :demand t
    :bind (("C-M-=" . imalison:hydra-font-resize/body)
           ("C-c y" . imalison:hydra-yank/body))
    :config
    (progn
      (defhydra imalison:hydra-font-resize
        nil
        "font-resize"
        ("-"   imalison:font-size-decr  "Decrease")
        ("="   imalison:font-size-incr  "Increase")
        ("0"   imalison:font-size-reset "Reset to default size"))

      (defhydra imalison:hydra-yank
        nil
        "Yank text"
        ("p" imalison:copy-buffer-file-path "Projectile path")
        ("f" imalison:copy-buffer-file-path-full "Full path")
        ("n" imalison:copy-buffer-file-name "File name")
        ("b" imalison:copy-current-git-branch "Git Branch"))))
#+END_SRC
** org
*** main
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :preface
    (progn
      (defvar-setq org-directory "~/Dropbox/org")
      (defvar-setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
      (defvar-setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
      (add-hook 'org-mode-hook 'imalison:disable-linum-mode)
      (add-hook 'org-mode-hook 'imalison:disable-smartparens-mode)
      (add-hook 'org-mode-hook (lambda () (setq org-todo-key-trigger t)))
      (add-hook 'org-agenda-mode-hook 'imalison:disable-linum-mode)
      (defun org-archive-if (condition-function)
        (if (funcall condition-function)
            (let ((next-point-marker
                   (save-excursion (org-forward-heading-same-level 1) (point-marker))))
              (org-archive-subtree)
              (setq org-map-continue-from (marker-position next-point-marker)))))

      (defun org-archive-if-completed ()
        (interactive)
        (org-archive-if 'org-entry-is-done-p))

      (defun org-archive-completed-in-buffer ()
        (interactive)
        (org-map-entries 'org-archive-if-completed))

      (cl-defun org-capture-make-todo-template
          (&key (content "%?") (creation-state "TODO"))
        (with-temp-buffer
          (org-mode)
          (org-insert-heading)
          (insert content)
          (org-todo creation-state)
          (org-set-property "CREATED"
                            (with-temp-buffer
                              (org-insert-time-stamp
                               (org-current-effective-time) t t)))
          (remove-hook 'post-command-hook 'org-add-log-note)
          (let ((org-log-note-purpose 'state)
                (org-log-note-return-to (point-marker))
                (org-log-note-marker (progn (goto-char (org-log-beginning t))
                                            (point-marker)))
                (org-log-note-state creation-state))
            (org-add-log-note))
          (buffer-substring-no-properties (point-min) (point-max))))

      (defun org-todo-force-notes ()
        (interactive)
        (let ((org-todo-log-states
               (mapcar (lambda (state)
                         (list state 'note 'time))
                       (apply 'append org-todo-sets))))
          (cond ((eq major-mode 'org-mode)  (org-todo))
                ((eq major-mode 'org-agenda-mode) (org-agenda-todo)))))

      (defun org-make-habit ()
        (interactive)
        (org-set-property "STYLE" "habit"))

      (defun org-insert-habit ()
        (interactive)
        (org-insert-todo-heading nil)
        (org-make-habit))

      (defun org-todo-at-date (date)
        (interactive (list (org-time-string-to-time (org-read-date))))
        (cl-flet ((org-current-effective-time (&rest r) date)
                  (org-today (&rest r) (time-to-days date)))
          (cond ((eq major-mode 'org-mode) (org-todo))
                ((eq major-mode 'org-agenda-mode) (org-agenda-todo)))))

      (defun org-capture-make-linked-todo-template ()
        (org-capture-make-todo-template "%? %A"))

      (defun org-cmp-creation-times (a b)
        (let ((a-created (get-date-created-from-agenda-entry a))
              (b-created (get-date-created-from-agenda-entry b)))
          (imalison:compare-int-list a-created b-created)))

      (defun org-agenda-done (&optional arg)
        "Mark current TODO as done.
    This changes the line at point, all other lines in the agenda referring to
    the same tree node, and the headline of the tree node in the Org-mode file."
        (interactive "P")
        (org-agenda-todo "DONE")))
    :commands (org-mode org org-mobile-push org-mobile-pull org-agenda)
    :mode ("\\.org\\'" . org-mode)
    :bind (("C-c a" . org-agenda)
           ("C-c c" . org-capture)
           :map org-mode-map
           ("C-c n t" . org-insert-todo-heading)
           ("C-c n s" . org-insert-todo-subheading)
           ("C-c n h" . org-insert-habit)
           ("C-c n m" . org-make-habit)
           ("C-c n l" . org-store-link)
           ("C-c n i" . org-insert-link)
           ("C-c C-t" . org-todo)
           ("C-c C-S-t" . org-todo-force-notes)
           ("M-." . elisp-slime-nav-find-elisp-thing-at-point))
    :config
    (progn
      (setq org-global-properties
            '(quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                     ("STYLE_ALL" . "habit"))))
            ;; Record changes to todo states
      (setq org-todo-keywords
            '((sequence "IDEA(i!)" "RESEARCH(r!)" "TODO(t!)" "NEXT(n!)"
                        "STARTED(s!)" "WAIT(w!)" "BACKLOG(b!)" "|"
                        "DONE(d!)" "HANDLED(h!)" "EXPIRED(e!)" "CANCELED(c!)")))

      (defvar-setq helm-org-headings-fontify t)
      (setq org-todo-repeat-to-state "TODO")

      (setq org-agenda-span 10)
      (setq org-agenda-start-day "-2d")

      (setq org-columns-default-format
            "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

      (org-babel-do-load-languages
       'org-babel-load-languages
       '((sh . t)
         (python . t)
         (ruby . t)
         (octave . t)
         (sqlite . t)))

      (setq org-log-into-drawer t)

      (when nil
        ;; Enable appointment notifications.
        (defadvice org-agenda-to-appt (before wickedcool activate)
          "Clear the appt-time-msg-list."
          (setq appt-time-msg-list nil))
        (appt-activate)
        (defun org-agenda-to-appt-no-message ()
          (shut-up (org-agenda-to-appt)))
        (run-at-time "00:00" 60 'org-agenda-to-appt-no-message))


      ;; Override the key definition for org-exit
      ;; TODO why does this cause an error
      ;; (define-key org-agenda-mode-map "x" #'org-agenda-done)

      ;; org-mode add-ons
      (use-package org-present
        :commands org-present)
      (use-package org-pomodoro
        :disabled t)

      ;; variable configuration
      (add-to-list 'org-modules 'org-habit)
      (add-to-list 'org-modules 'org-expiry)
      (add-to-list 'org-modules 'org-notify)

      (setq org-src-fontify-natively t)
      (setq org-habit-graph-column 50)
      (setq org-habit-show-habits-only-for-today t)

      ;; My priority system:

      ;; A - Absolutely MUST, at all costs, be completed by the provided
      ;;     due date. TODO: implement some type of extreme nagging
      ;;     system that alerts in an intrusive way for overdue A
      ;;     priority tasks.

      ;; B - Should be given immediate attention if the due date is any
      ;;     time in the next two days. Failure to meet due date would
      ;;     be bad but not catastrophic.

      ;; C - The highest priority to which tasks for which failure to
      ;;     complete on time would not have considerable significant
      ;;     consequences. There is still significant reason to prefer
      ;;     the completion of these tasks sooner rather than later.

      ;; D - Failure to complete within a few days (or ever) of any
      ;;     deadline would be completely okay. As such, any deadline
      ;;     present on such a task is necessarily self imposed. Still
      ;;     probably worth doing

      ;; E - Potentially not even worth doing at all, but worth taking a
      ;;     note about in case it comes up again, or becomes more
      ;;     interesting later.

      ;; F - Almost certainly not worth attempting in the immediate future.
      ;;     Just brain dump.

      ;; Priorities are somewhat contextual within each category. Things
      ;; in the gtd or work categories are generally regarded as much
      ;; more important than things with the same priority from the
      ;; dotfiles category.

      ;; Items without deadlines or scheduled times of a given priority
      ;; can be regarded as less important than items that DO have
      ;; deadlines of that same priority.

      (setq org-lowest-priority 69) ;; The character E
      (setq org-completion-use-ido t)
      (setq org-enforce-todo-dependencies t)
      (setq org-deadline-warning-days 0)
      (setq org-default-priority ?D)
      (setq org-agenda-skip-scheduled-if-done t)
      (setq org-agenda-skip-deadline-if-done t)
      ;;(add-to-list org-agenda-tag-filter-preset "+PRIORITY<\"C\"")

      (setq org-imenu-depth 3)

      ;; Stop starting agenda from deleting frame setup!
      (setq org-agenda-window-setup 'other-window)
      (define-key mode-specific-map [?a] 'org-agenda)
      (unbind-key "C-j" org-mode-map)

      (use-package org-bullets
        :config
        (progn
          (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))

      (use-package org-ehtml
        :disabled t
        :config
        (progn
          (setq org-ehtml-docroot (expand-file-name "~/Dropbox/org"))
          (setq org-ehtml-allow-agenda t)
          (setq org-ehtml-editable-headlines t)
          (setq org-ehtml-everything-editable t)))

      ;; Agenda setup.
      (defvar-setq imalison:org-gtd-file "~/org/gtd.org")
      (defvar-setq imalison:org-habits-file "~/org/habits.org")
      (defvar-setq imalison:org-calendar-file "~/org/calendar.org")

      (unless (boundp 'org-capture-templates)
        (defvar org-capture-templates nil))

      (imalison:add-to-org-agenda-files
       (list imalison:org-gtd-file imalison:org-habits-file
             imalison:org-calendar-file))

      (add-to-list 'org-capture-templates
                   `("t" "GTD Todo (Linked)" entry (file ,imalison:org-gtd-file)
                     (function org-capture-make-linked-todo-template)))

      (add-to-list 'org-capture-templates
                   `("g" "GTD Todo" entry (file ,imalison:org-gtd-file)
                     (function org-capture-make-todo-template)))

      (add-to-list 'org-capture-templates
                   `("y" "Calendar entry (Linked)" entry
                     (file ,imalison:org-calendar-file)
                     "* %? %A
      :PROPERTIES:
      :CREATED: %U
      :END:
    %^T"))

      (add-to-list 'org-capture-templates
                   `("c" "Calendar entry" entry
                     (file ,imalison:org-calendar-file)
                     "* %?
      :PROPERTIES:
      :CREATED: %U
      :END:
    %^T"))

      (add-to-list 'org-capture-templates
                   `("h" "Habit" entry (file ,imalison:org-habits-file)
                     "* TODO
      SCHEDULED: %^t
      :PROPERTIES:
      :CREATED: %U
      :STYLE: habit
      :END:"))

      (let ((this-week-high-priority
             ;; The < in the following line works has behavior that is opposite
             ;; to what one might expect.
             '(tags-todo "+PRIORITY<\"C\"+DEADLINE<\"<+1w>\"DEADLINE>\"<+0d>\""
                         ((org-agenda-overriding-header
                           "Upcoming high priority tasks:"))))
            (due-today '(tags-todo
                         "+DEADLINE=<\"<+0d>\""
                         ((org-agenda-overriding-header
                           "Due today:"))))
            (recently-created '(tags-todo
                                "+CREATED=>\"<-3d>\""
                                ((org-agenda-overriding-header "Recently created:")
                                 (org-agenda-cmp-user-defined 'org-cmp-creation-times)
                                 (org-agenda-sorting-strategy '(user-defined-down)))))
            (next '(todo "NEXT"))
            (started '(todo "STARTED"))
            (missing-deadline
             '(tags-todo "-DEADLINE={.}/!"
                         ((org-agenda-overriding-header
                           "These don't have deadlines:"))))
            (missing-priority
             '(tags-todo "-PRIORITY={.}/!"
                         ((org-agenda-overriding-header
                           "These don't have priorities:")))))

        (setq org-agenda-custom-commands
              `(("M" "Main agenda view"
                 ((agenda ""
                          ((org-agenda-overriding-header "Agenda:")
                           (org-agenda-ndays 5)
                           (org-deadline-warning-days 0)))
                  ,due-today
                  ,next
                  ,started
                  ,this-week-high-priority
                  ,recently-created)
                 nil nil)
                ,(cons "A" (cons "High priority upcoming" this-week-high-priority))
                ,(cons "d" (cons "Overdue tasks and due today" due-today))
                ,(cons "r" (cons "Recently created" recently-created))
                ("h" "A, B priority:" tags-todo "+PRIORITY<\"C\""
                 ((org-agenda-overriding-header
                   "High Priority:")))
                ("c" "At least priority C:" tags-todo "+PRIORITY<\"D\""
                 ((org-agenda-overriding-header
                   "At least priority C:"))))))

      ;; What follows is a description of the significance of each of
      ;; the values available in `org-todo-keywords'. All headings with
      ;; one of these keywords deal with the concept of the completion
      ;; of some task or collection of tasks to bring about a particular
      ;; state of affairs. In some cases, the actual tasks involved may
      ;; not be known at the time of task creation.

      ;; Incomplete States:

      ;; IDEA - This TODO exists in only the most abstract sense: it is
      ;; an imagined state of affairs that requires tasks that are
      ;; either not yet known, or have not thoroughly been considered.

      ;; RESEARCH - This TODO needs to be investigated further before
      ;; action can be taken to achieve the desired outcome. It is not
      ;; known how much time and effort will be consumed in the actual
      ;; completion of the task.

      ;; TODO - The scope and work involved in this TODO are well
      ;; understood, but for some reason or another, it is not something
      ;; that should be attempted in the immediate future. Typically
      ;; this is because the task is not considered a top priority, but
      ;; it may also be for some other reason.

      ;; NEXT - This TODO is immediately actionable and should be
      ;; started in the immediate future.

      ;; STARTED - Work on this TODO has already started, further work
      ;; is immediately actionable.

      ;; WAIT - The work involved in this TODO is well understood, but
      ;; it is blocked for the time being.

      ;; BACKLOG - While technically actionable, this task is not only
      ;; not worth pursuing in the immediate future, but the foreseable
      ;; future. It exists as a task mostly as a note/reminder, in case
      ;; it becomes higher priority in the future.

      ;; Complete States:

      ;; DONE - This TODO has been completed exactly as imagined.

      ;; HANDLED - This TODO was completed in spirit, though not by the
      ;; means that were originally imagined/outlined in the TODO.

      ;; EXPIRED - The owner of this TODO failed to take action on it
      ;; within the appropriate time period, and there is now no point in
      ;; attempting it.

      ;; CANCELED - For whatever reason, this TODO should no longer be
      ;; attempted. This TODO is typically used in contrast to the
      ;; EXPIRED TODO to indicate that the owner is not necessarily to
      ;; blame.
      ))
#+END_SRC
*** org-projectile
#+BEGIN_SRC emacs-lisp
  (imalison:use-package org-projectile
    :after helm
    :bind (("C-c n p" . imalison:helm-org-todo))
    :config
    (progn
      (org-projectile:prompt)
      (add-to-list 'org-capture-templates
                   (org-projectile:project-todo-entry
                    "l" "* TODO %? %a\n" "Linked Project TODO"))
      (add-to-list 'org-capture-templates (org-projectile:project-todo-entry "p"))
      (setq org-confirm-elisp-link-function nil)
      (imalison:add-to-org-agenda-files (org-projectile:todo-files))
      (defun imalison:helm-org-todo (&optional arg)
        (interactive "P")
        (helm :sources (list (helm-source-org-capture-templates)
                             (org-projectile:helm-source
                              (if arg (org-capture-make-linked-todo-template)
                                (org-capture-make-todo-template))))
              :candidate-number-limit 99999
              :buffer "*helm org capture templates*"))))
#+END_SRC
*** org-notify
#+BEGIN_SRC emacs-lisp
  (use-package org-notify
    :disabled t
    :after org
    :config
    (progn
      (defun imalison:org-notify-notification-handler (plist)
        (sauron-add-event 'org-notify 4 (format "%s, %s.\n" (plist-get plist :heading)
                                                (org-notify-body-text plist))))

      (setq org-show-notification-handler 'imalison:org-notify-notification-handler)

      (org-notify-add 'default '(:time "1h" :actions imalison:org-notify-notification-handler
                                       :period "2m" :duration 60))
      (org-notify-add 'default '(:time "100m" :actions imalison:org-notify-notification-handler
                                       :period "2m" :duration 60))
      (org-notify-add 'urgent-second '(:time "3m" :actions (-notify/window -ding)
                                             :period "15s" :duration 10))
      (org-notify-add 'minute '(:time "5m" :actions -notify/window
                                      :period "100s" :duration 70))
      (org-notify-add '12hours
                      '(:time "3m" :actions (-notify/window -ding)
                              :period "15s" :duration 10)
                      '(:time "100m" :actions -notify/window
                              :period "2m" :duration 60)
                      '(:time "12h" :actions -notify/window :audible nil
                              :period "10m" :duration 200))
      (org-notify-add '5days
                      '(:time "100m" :actions -notify/window
                              :period "2m" :duration 60)
                      '(:time "2d" :actions -notify/window
                              :period "15m" :duration 100)
                      '(:time "5d" :actions -notify/window
                              :period "2h" :duration 200))
      (org-notify-add 'long-20days
                      '(:time "2d" :actions -notify/window
                              :period "15m" :duration 60)
                      '(:time "5d" :actions -notify/window
                              :period "2h" :duration 60)
                      '(:time "20d" :actions -email :period "2d" :audible nil))
      (org-notify-add 'long-50days
                      '(:time "4d" :actions -notify/window
                              :period "30m" :duration 100)
                      '(:time "10d" :actions -notify/window
                              :period "4h" :duration 200)
                      '(:time "50d" :actions -email :period "3d" :audible nil))
      (org-notify-add 'long-100days
                      '(:time "2d" :actions -notify/window
                              :period "1h" :duration 200)
                      '(:time "10d" :actions -notify/window
                              :period "10h" :duration 300)
                      '(:time "50d" :actions -email :period "3d" :audible nil)
                      '(:time "100d" :actions -email :period "5d" :audible nil))
      (org-notify-start 10)))
#+END_SRC
** Navigation/Completion
*** zop-to-char
#+BEGIN_SRC emacs-lisp
  (use-package zop-to-char
    :bind ("M-z" . zop-to-char))
#+END_SRC
*** helm
I use helm for almost all emacs completion
#+BEGIN_SRC emacs-lisp -n -r
  (use-package helm-config
    :ensure helm
    :demand t
    :bind (("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x C-i" . helm-imenu)
           ("C-h a" . helm-apropos)
           ("C-c C-h" . helm-org-agenda-files-headings)
           ("C-c ;" . helm-recentf))
    :diminish helm-mode
    :config
    (progn
      (setq helm-split-window-default-side 'same)         (ref:helm split window)

      (defun helm-source-org-capture-templates ()
        (helm-build-sync-source "Org Capture Templates:"
          :candidates (cl-loop for template in org-capture-templates
                               collect `(,(nth 1 template) . ,(nth 0 template)))
          :action '(("Do capture" . (lambda (template-shortcut)
                                      (org-capture nil template-shortcut))))))

      (defun helm-org-capture-templates ()
        (interactive)
        (helm :sources (helm-source-org-capture-templates)
              :candidate-number-limit 99999
              :buffer "*helm org capture templates*"))

      (cl-defun helm-org-headings-in-buffer ()
        (interactive)
        (helm :sources (helm-source-org-headings-for-files
                        (list (projectile-completing-read
                               "File to look at headings from: "
                               (projectile-all-project-files))))
              :candidate-number-limit 99999
              :buffer "*helm org inbuffer*"))
      ;; helm zsh source history
      (defvar helm-c-source-zsh-history
        '((name . "Zsh History")
          (candidates . helm-c-zsh-history-set-candidates)
          (action . (("Execute Command" . helm-c-zsh-history-action)))
          (volatile)
          (requires-pattern . 3)
          (delayed)))

      (defun helm-c-zsh-history-set-candidates (&optional request-prefix)
        (let ((pattern (replace-regexp-in-string
                        " " ".*"
                        (or (and request-prefix
                                 (concat request-prefix
                                         " " helm-pattern))
                            helm-pattern))))
          (with-current-buffer (find-file-noselect "~/.zsh_history" t t)
            (auto-revert-mode -1)
            (goto-char (point-max))
            (loop for pos = (re-search-backward pattern nil t)
                  while pos
                  collect (replace-regexp-in-string
                           "\\`:.+?;" ""
                           (buffer-substring (line-beginning-position)
                                             (line-end-position)))))))

      (defun helm-c-zsh-history-action (candidate)
        (async-shell-command candidate))

      (defun helm-command-from-zsh ()
        (interactive)
        (require 'helm)
        (helm-other-buffer 'helm-c-source-zsh-history "*helm zsh history*"))

      (use-package helm-descbinds
        :demand t
        :config (helm-descbinds-mode 1))

      (use-package helm-ag
        :bind ("C-c p S" . imalison:set-helm-ag-extra-options)
        :config
        (progn
          (setq helm-ag-always-set-extra-option nil)
          (defun imalison:set-helm-ag-extra-options ()
            (interactive)
            (let ((option (read-string "Extra options: " (or helm-ag--extra-options "")
                                       'helm-ag--extra-options-history)))
              (setq helm-ag--extra-options option)))))
      (helm-mode 1)))
#+END_SRC
[[(helm split window)][Ensure that helm buffers are started in the window that currently holds the focus]]
*** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :commands (helm-projectile-on)
    :bind (:map helm-projectile-projects-map
                ("M-s" . imalison:switch-to-project-and-search)
                ("M-t" . imalison:helm-term-projectile))
    :preface
    (progn
      (defun imalison:invalidate-cache-and-open-file (_dir)
        (projectile-invalidate-cache nil)
        (projectile-find-file))

      (defun imalison:switch-to-project-and-search (dir)
        (let ((default-directory dir)
              (projectile-require-project-root nil)
              (helm-action-buffer "this-buffer-should-not-exist"))
          (helm-projectile-ag)))

      (defun imalison:helm-term-projectile (dir)
        (let ((default-directory dir)
              (projectile-require-project-root nil)
              (helm-action-buffer "this-buffer-should-not-exist"))
          (term-projectile-forward))))
    :config
    (progn
      (helm-delete-action-from-source "Search in Project"
                                      helm-source-projectile-projects)
      (helm-delete-action-from-source "Open term for project"
                                      helm-source-projectile-projects)
      (helm-add-action-to-source "Search in Project"
                                 'imalison:switch-to-project-and-search
                                 helm-source-projectile-projects)
      (helm-add-action-to-source "Open term for project"
                                 'imalison:helm-term-projectile
                                 helm-source-projectile-projects)
      (helm-add-action-to-source "Invalidate Cache and Open File"
                                 'imalison:invalidate-cache-and-open-file
                                 helm-source-projectile-projects)))
#+END_SRC
*** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand t
    :bind (("C-x f" . projectile-find-file-in-known-projects)
           ("C-c p f" . imalison:projectile-find-file))
    :preface
    (progn
      (defun imalison:do-ag-default-directory ()
        (interactive)
        (helm-do-ag default-directory (car (projectile-parse-dirconfig-file))))

      (imalison:prefix-alternatives imalison:do-ag helm-projectile-ag
                                    imalison:do-ag-default-directory helm-do-ag)
      (imalison:prefix-alternatives imalison:projectile-find-file
                                    projectile-find-file
                                    projectile-find-file-other-window)

      (defun projectile-make-all-subdirs-projects (directory)
        (cl-loop for file-info in (directory-files-and-attributes directory)
                 do (when (nth 1 file-info)
                      (write-region "" nil
                                    (expand-file-name
                                     (concat directory "/"
                                             (nth 0 file-info) "/.projectile")))))))
    :config
    (progn
      (use-package persp-projectile
        :commands projectile-persp-switch-project)

      (projectile-global-mode)
      (setq projectile-require-project-root nil)
      (setq projectile-enable-caching nil)
      (setq projectile-completion-system 'helm)
      (add-to-list 'projectile-globally-ignored-files "Godeps")
      (add-to-list 'projectile-globally-ignored-files "thrift-binaries")
      (shut-up (helm-projectile-on))
      (diminish 'projectile-mode)
      (bind-key* "C-c p s" 'imalison:do-ag)
      (bind-key* "C-c p f" 'imalison:projectile-find-file)))
#+END_SRC
*** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :preface
    (progn
      (imalison:prefix-alternatives imalison:avy avy-goto-word-1 avy-goto-char))
    :bind (("C-j" . imalison:avy)
           ("M-g l" . avy-goto-line)
           ("C-'" . avy-goto-char-2)))
#+END_SRC
*** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :preface
    (imalison:prefix-alternatives imalison:ace-window ace-select-window ace-swap-window)
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind ("C-c w" . imalison:ace-window))
#+END_SRC
*** neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree)
#+END_SRC
*** jump-char
#+BEGIN_SRC emacs-lisp
  (use-package jump-char
    :bind (("C-;" . jump-char-forward)))
#+END_SRC
** Text Manipulation
*** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :demand t
    :diminish smartparens-mode
    :bind (:map smartparens-mode-map
                ("C-)" . sp-forward-slurp-sexp)
                ("C-}" . sp-forward-barf-sexp)
                ("C-(" . sp-backward-slurp-sexp)
                ("C-{" . sp-backward-barf-sexp))
    :config
    (progn
      (require 'smartparens-config)
      (smartparens-global-mode 1)
      (sp-use-smartparens-bindings)
      (unbind-key "C-<backspace>" smartparens-mode-map)
      (unbind-key "M-<backspace>" smartparens-mode-map)))
#+END_SRC
*** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :config
    (progn
      (use-package phi-search-mc
        :config
        (phi-search-mc/setup-keys))
      (use-package mc-extras
        :config
        (define-key mc/keymap (kbd "C-. =") 'mc/compare-chars)))
    :bind
    (("C-c m a" . mc/mark-all-like-this)
     ("C-c m m" . mc/mark-all-like-this-dwim)
     ("C-c m l" . mc/edit-lines)
     ("C-c m n" . mc/mark-next-like-this)
     ("C-c m p" . mc/mark-previous-like-this)
     ("C-c m s" . mc/mark-sgml-tag-pair)
     ("C-c m d" . mc/mark-all-like-this-in-defun)))
#+END_SRC
*** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :commands er/expand-region
    :config (setq expand-region-contract-fast-key "j")
    :bind (("C-c k" . er/expand-region)))
#+END_SRC
*** multi-line
#+BEGIN_SRC emacs-lisp
  (imalison:use-package multi-line
    :preface
    (progn
      (defun imalison:multi-line-fill-column ()
        (interactive)
        (multi-line-execute multi-line-fill-column-strategy nil))

      (defun imalison:multi-line-skip-fill ()
        (interactive)
        (multi-line-execute multi-line-skip-fill-stragety nil))

      (defun imalison:multi-line-fill ()
        (interactive)
        (multi-line-execute multi-line-fill-stragety nil))

      (imalison:prefix-alternatives imalison:multi-line multi-line
                                    multi-line-single-line
                                    imalison:multi-line-skip-fill
                                    imalison:multi-line-fill
                                    imalison:multi-line-fill-column))
      :bind ("C-c d" . imalison:multi-line))
#+END_SRC
*** comment-dwim-2
#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
    :bind ("M-;" . comment-dwim-2))
#+END_SRC
*** string-inflection
#+BEGIN_SRC emacs-lisp
  (use-package string-inflection
    :commands string-inflection-toggle
    :bind ("C-c l" . string-inflection-toggle))
#+END_SRC

*** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :defer 5
    :commands (yas-global-mode)
    :config
    (progn
      (yas-global-mode)
      (diminish 'yas-minor-mode)
      (add-hook 'term-mode-hook (lambda() (yas-minor-mode -1)))
      (setq yas-prompt-functions
            (cons 'yas-ido-prompt
                  (cl-delete 'yas-ido-prompt yas-prompt-functions)))))

#+END_SRC
** Source Control
*** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands magit-status
    :bind (("C-x g" . magit-status))
    :config
    (progn
      (defvar-setq magit-last-seen-setup-instructions "1.4.0")
      (magit-auto-revert-mode)
      (when imalison:gpg-key
        (add-to-list 'magit-commit-arguments
                     (format "--gpg-sign=%s" imalison:gpg-key)))
      (use-package magit-filenotify
        ;; Seems like OSX does not support filenotify.
        :disabled t
        :if (funcall o(emacs-version-predicate 24 4))
        :config
        :init (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))))
#+END_SRC
*** git-link
#+BEGIN_SRC emacs-lisp
  (use-package git-link
    :config
    (progn
      (setq git-link-use-commit t)))
#+END_SRC
*** magit-gitflow
#+BEGIN_SRC emacs-lisp
  (use-package magit-gitflow
    :diminish magit-gitflow-mode
    :after magit
    :config
    (progn
      (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)))
#+END_SRC
*** git-timemachine
#+BEGIN_SRC emacs-lisp
    (use-package git-timemachine
      :commands git-timemachine)
#+END_SRC
*** git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :config
    (progn
      (global-git-gutter-mode -1)))
#+END_SRC
*** gitolite-clone
#+BEGIN_SRC emacs-lisp
  (use-package gitolite-clone
    :demand t
    :preface
    (progn
      (defun gitolite-clone-force-refresh ()
        (interactive)
        (gitolite-clone-get-projects nil nil t))))
#+END_SRC
*** github
**** github-search
#+BEGIN_SRC emacs-lisp
  (imalison:use-package github-search
    :commands (github-search-clone-repo github-search-user-clone-repo)
    :preface
    (progn
      (defun imalison:get-projects-directory-target-from-repo (repo)
        (let ((prospective-path
               (imalison:join-paths imalison:projects-directory (oref repo :name))))
              (if (file-exists-p prospective-path)
                  (funcall 'github-search-prompt-for-target-directory repo)
                prospective-path))))
    :config
    (progn
      (setq github-search-get-target-directory-for-repo-function
            'imalison:get-projects-directory-target-from-repo)))
#+END_SRC
**** github-clone
#+BEGIN_SRC emacs-lisp
  (imalison:use-package* github-clone "~/Projects/github-clone.el"
    :commands (github-clone-add-parent-remote
               github-clone-add-source-remote
               github-clone-fork-remote
               github-clone-add-existing-remote
               github-clone))
#+END_SRC
**** github-notifier
#+BEGIN_SRC emacs-lisp
  (use-package github-notifier
    :disabled t
    :config (github-notifier-mode))
#+END_SRC
**** github-browse-file
#+BEGIN_SRC emacs-lisp
  (use-package github-browse-file
    :commands github-browse-file)
#+END_SRC
**** magit-gh-pulls
#+BEGIN_SRC emacs-lisp
  (use-package magit-gh-pulls
    :diminish magit-gh-pulls-mode
    :after magit
    :config
    (progn
      (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)))
#+END_SRC
**** gist
#+BEGIN_SRC emacs-lisp
  (use-package gist
    :commands (gist-region gist-region-private gist-buffer gist-buffer-private
                           gist-region-or-buffer gist-region-or-buffer-private
                           gist-list-user gist-list gist-fetch gist-star
                           gist-unstar gist-list-starred gist-fork))
#+END_SRC
** Programming
*** Language Specific
**** python
#+BEGIN_SRC emacs-lisp
  (defvar use-python-tabs nil)

  (defun python-tabs ()
    (setq tab-width 4 indent-tabs-mode t python-indent-offset 4))

  (defun add-virtual-envs-to-jedi-server ()
    (let ((virtual-envs (get-virtual-envs)))
      (when virtual-envs (set (make-local-variable 'jedi:server-args)
                              (make-virtualenv-args virtual-envs)))))

  (defun make-virtualenv-args (virtual-envs)
    (apply #'append (mapcar (lambda (env) `("-v" ,env)) virtual-envs)))

  (defun imalison:project-root-or-current-directory ()
    (if (projectile-project-p)
        (projectile-project-root) (if (buffer-file-name)
                                      (file-name-directory (buffer-file-name)))))

  (defun get-virtual-envs ()
    (let ((project-root (imalison:project-root-or-current-directory)))
      (when project-root
        (condition-case ex
            (cl-remove-if-not 'file-exists-p
                              (mapcar (lambda (env-suffix)
                                        (concat project-root env-suffix))
                                      '(".tox/py27/" "env/" ".tox/venv/")))
          ('error
           (message (format "Caught exception: [%s]" ex))
           (setq retval (cons 'exception (list ex))))
          nil))))

  (defun message-virtual-envs ()
    (interactive)
    (message "%s" (get-virtual-envs)))

  (use-package python
    :commands python-mode
    :mode ("\\.py\\'" . python-mode)
    :config
    (progn
      (fset 'main "if __name__ == '__main__':")
      (fset 'sphinx-class ":class:`~")
    :init
    (progn
      (unbind-key "C-j" python-mode-map)
      (use-package jedi
        :commands (jedi:goto-definition jedi-mode)
        :config
        (progn
          (setq jedi:complete-on-dot t)
          (setq jedi:imenu-create-index-function 'jedi:create-flat-imenu-index)
          (use-package company-jedi
            :commands company-jedi))
        :bind (:map python-mode-map
                    ("M-." . jedi:goto-definition)
                    ("M-," . jedi:goto-definition-pop-marker)))
      (use-package pymacs)
      (use-package sphinx-doc)
      (defun imalison:python-mode ()
        (setq show-trailing-whitespace t)
        (if use-python-tabs (python-tabs))
        (subword-mode t)
        (imalison:make-imenu-index-flat)
        (jedi:setup)
        (add-virtual-envs-to-jedi-server)
        (remove-hook 'completion-at-point-functions
                     'python-completion-complete-at-point 'local)
        (set (make-local-variable 'company-backends) '(company-jedi)))
      (add-hook 'python-mode-hook #'imalison:python-mode))))
#+END_SRC
**** go
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode (("\\.go\\'" . go-mode))
    :preface
    (progn
      (defun go-mode-glide-novendor ()
        (projectile-with-default-dir (projectile-project-root)
          (shell-command-to-string "glide novendor")))

      (defun go-mode-create-imenu-index ()
        "Create and return an imenu index alist. Unlike the default
  alist created by go-mode, this method creates an alist where
  items follow a style that is consistent with other prog-modes."
        (let* ((patterns '(("type" "^type *\\([^ \t\n\r\f]*\\)" 1)))
               (type-index (imenu--generic-function patterns))
               (func-index))
          (save-excursion
            (goto-char (point-min))
            (while (re-search-forward go-func-meth-regexp (point-max) t)
              (let* ((var (match-string-no-properties 1))
                     (func (match-string-no-properties 2))
                     (name (if var
                               (concat (substring var 0 -1) "." func)
                             func))
                     (beg (match-beginning 0))
                     (marker (copy-marker beg))
                     (item (cons name marker)))
                (setq func-index (cons item func-index)))))
          (nconc type-index (list (cons "func" func-index)))))

      (defun go-mode-workspace-path ()
        (file-relative-name (projectile-project-root)
                            (concat (file-name-as-directory
                                     (or (getenv "GOPATH") "~/go")) "src")))

      (defun go-mode-install-current-project ()
        (interactive)
        (start-process 
         "go install" "go install log" "go" "install"
         (concat (file-name-as-directory (go-mode-workspace-path)) "...")))

      (defun go-mode-get-go-path ()
        (file-name-as-directory (car (s-split ":" (getenv "GOPATH")))))

      (imalison:let-advise-around imalison:advise-normal-go-command
                                  (go-command "go"))

      (defun imalison:go-mode-hook ()
        (go-eldoc-setup)
        (set (make-local-variable 'company-backends) '(company-go))))
    :config
    (progn
      (use-package gotest
        :demand
        :bind (:map go-mode-map
                    ("C-c t" . imalison:gotest))
        :preface
        (progn
          (imalison:prefix-alternatives
           imalison:gotest go-test-current-test go-test-current-file))
        :config
        (progn
          (setq go-test-verbose t)))
      (use-package company-go
        :config (setq company-go-show-annotation t))
      (use-package go-projectile :demand t)
      (use-package go-eldoc :demand t)
      (use-package go-guru
        :demand t
        :bind (:map go-mode-map
                    ("M-." . go-guru-definition)
                    ("M-," . pop-tag-mark))
        :preface
        (progn
          (defun imalison:set-go-guru-scope ()
            (setq go-guru-scope (go-mode-parse-glide-novendor)))
          (defun go-mode-parse-glide-novendor ()
            (s-join ","
                    (cl-loop for path in (s-split "\n" (go-mode-glide-novendor))
                             collect (if (string-equal path ".")
                                         (go-mode-workspace-path)
                                       (s-replace "\./" (go-mode-workspace-path) path))))))
        :config
        (progn
          (advice-add 'go-guru--set-scope-if-empty :before 'imalison:set-go-guru-scope)
          (advice-add 'go-guru-start :before 'imalison:set-go-guru-scope)
          (advice-add 'go-guru-definition :around 'imalison:advise-normal-go-command)
          (advice-add 'go-guru-definition :before
                      (lambda ()
                        (with-no-warnings
                          (ring-insert find-tag-marker-ring (point-marker)))))))

      (advice-add 'go-import-add :around 'imalison:advise-normal-go-command)

      (setq gofmt-command "goimports")

      (add-hook 'go-mode-hook 'imalison:go-mode-hook)
      (add-hook 'before-save-hook 'gofmt-before-save t)
      (add-hook 'after-save-hook 'go-mode-install-current-project)))
#+END_SRC
**** emacs-lisp
***** elisp-slime-nav
#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :commands elisp-slime-nav-mode
    :config
    (diminish 'elisp-slime-nav-mode)
    :preface
    (imalison:prefix-alternatives imalison:elisp-slime-nav
                                  elisp-slime-nav-find-elisp-thing-at-point
                                  elisp-slime-nav-describe-elisp-thing-at-point)
    :bind (:map elisp-slime-nav-mode-map
                ("M-." . imalison:elisp-slime-nav))
    :init
    (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
#+END_SRC
***** macrostep
Macrostep is an indespensible tool for writing emacs lisp macros. It lets you see pretty printed versions of the result of macro evaluation as the macro is evaluated
#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :bind (:map lisp-mode-shared-map
                ("C-c e" . macrostep-expand)))
#+END_SRC
***** emr
#+BEGIN_SRC emacs-lisp
  (use-package emr
    :bind ("M-RET" . emr-show-refactor-menu)
    :config
    (progn
      (add-hook 'prog-mode-hook 'emr-initialize)))
#+END_SRC
***** Editing configuration
Reduce indentation for some functions
#+BEGIN_SRC emacs-lisp
  (put 'use-package 'lisp-indent-function 1)
#+END_SRC
***** edebug
#+BEGIN_SRC emacs-lisp
  (use-package edebug
    :config
    (progn (setq edebug-trace t)))
#+END_SRC
***** Misc
#+BEGIN_SRC emacs-lisp
  (defun imenu-elisp-sections ()
    (setq imenu-prev-index-position-function nil)
    (setq imenu-space-replacement nil)
    (add-to-list 'imenu-generic-expression
                 `("Package"
                   ,"(use-package \\(.+\\)$" 1))
    (add-to-list 'imenu-generic-expression
                 `("Section"
                   ,(concat ";\\{1,4\\} =\\{10,80\\}\n;\\{1,4\\} \\{10,80\\}"
                            "\\(.+\\)$") 1) t))

  (defun imalison:maybe-remove-flycheck-checkdoc-checker ()
    (when (s-starts-with? "*" (buffer-name))
      (flycheck-disable-checker 'emacs-lisp-checkdoc)))

  (add-hook 'emacs-lisp-mode-hook 'imenu-elisp-sections)
  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (setq indent-tabs-mode nil)
                                    (setq show-trailing-whitespace t)))
  (add-hook 'flycheck-mode-hook 'imalison:maybe-remove-flycheck-checkdoc-checker)
#+END_SRC
***** Keybinds
#+BEGIN_SRC emacs-lisp
  (define-key lisp-mode-shared-map (kbd "C-c C-c") 'eval-defun)
  (define-key lisp-mode-shared-map (kbd "C-c C-r") 'eval-and-replace)
  (define-key lisp-mode-shared-map (kbd "C-c o r") 'up-list-region)
  (define-key lisp-mode-shared-map (kbd "C-c o o") 'up-list-back)
  (define-key lisp-mode-shared-map (kbd "C-x C-e") 'eval-region-or-last-sexp)
  (unbind-key "C-j" lisp-interaction-mode-map)
#+END_SRC
**** scala
#+BEGIN_SRC emacs-lisp
  (use-package scala-mode2
    :mode (("\\.scala\\'" . scala-mode)
           ("\\.sc\\'" . scala-mode))
    :config
    (progn
      (when (use-package ensime
              :bind (:map ensime-mode-map
                          ("M-," . ensime-pop-find-definition-stack))
              :commands ensime-mode)
        (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
      (setq scala-indent:align-parameters t)))
#+END_SRC
**** js
#+BEGIN_SRC emacs-lisp
  (defun tape-onlyify ()
    (interactive)
    (save-excursion
      (move-end-of-line nil)
      (re-search-backward "^test")
      (forward-sexp)
      (if (looking-at ".only") (progn (zap-to-char 1 (string-to-char "(")) (insert "("))
        (insert ".only"))))

  (use-package js2-mode
    :commands (js2-mode)
    :mode "\\.js\\'"
    :bind
    ;; (("C-c b" . web-beautify-js)) TODO: to make this mode specific
    ;; and change binding
    :preface
    (progn
      (defvar-setq imalison:identifier-count 0)
      (defun imalison:console-log-unique ()
        (interactive)
        (let* ((identifier-string (int-to-string imalison:identifier-count))
               (uuid (imalison:uuid)))
        (insert (format "console.log('%s//////////%s//////////');" identifier-string uuid))
        (setq imalison:identifier-count (+ imalison:identifier-count 1))))
      (defun imalison:js2-mode-hook ()
        ;; Sensible defaults
        (setq js2-bounce-indent-p nil
              js2-indent-level 4
              js2-basic-offset 4
              js2-highlight-level 3
              js2-include-node-externs t
              js2-mode-show-parse-errors nil
              js2-mode-show-strict-warnings nil
              indent-tabs-mode nil
              js2-indent-switch-body t)
        ;; (edconf-find-file-hook) ;; Make sure that editorconfig takes precedence
        (tern-mode t)
        (when nil (skewer-mode)) ;; TODO: reenable
        (setq imenu-create-index-function
              (lambda ()
                (imalison:flatten-imenu-index
                 (js2-mode-create-imenu-index))))))
    :init
    (progn
      (add-hook 'js2-mode-hook 'imalison:js2-mode-hook)
      (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)))

  (use-package js2-refactor
    :after js2-mode
    :config
    (progn
      (js2r-add-keybindings-with-prefix "C-c C-m")
      (add-hook 'js2-mode-hook #'js2-refactor-mode)))

  (use-package skewer-mode
    :commands skewer-mode
    :config
    (progn
      (add-hook 'css-mode-hook #'skewer-css-mode)
      (add-hook 'html-mode-hook #'skewer-html-mode)))

  (use-package tern
    :commands tern-mode
    :config
    (use-package company-tern
      :config (add-to-list 'company-backends 'company-tern)))

  (defun delete-tern-process ()
    (interactive)
    (delete-process "tern"))
#+END_SRC
**** rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode (("\\.rs\\'" . rust-mode))
    :config
    (progn
      (use-package flycheck-rust
        :demand t
        :config
        (progn
          (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))
      (use-package racer
        :demand t
        :config
        (progn
          (setq racer-cmd "~/.cargo/bin/racer")
          (setq racer-rust-src-path "~/Projects/rust/src")))
      (use-package cargo
        :demand t
        :config
        (progn
          (add-hook 'rust-mode-hook 'cargo-minor-mode)))
      (add-hook 'rust-mode-hook 'imalison:rust-mode-hook)))
#+END_SRC
**** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :commands haskell-mode
    :config
    (progn
      (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)))
#+END_SRC
**** Other
#+BEGIN_SRC emacs-lisp
  (defvar packages-eager
    '(popup cl-lib xclip dired+ ctags ctags-update aggressive-indent imenu+
      neotree gist))

  (ensure-packages-installed packages-eager)
#+END_SRC
*** Language Agnostic
**** realgud
realgud provides debugging support with many external debuggers in emacs
#+BEGIN_SRC emacs-lisp
  (use-package realgud
    :defer 10)
#+END_SRC
**** emr
emr (emacs refactor) provides support for refactoring in many programming languages
#+BEGIN_SRC emacs-lisp
  (use-package emr
    :bind (:map prog-mode-map
                ("M-RET" . emr-show-refactor-menu))
    :config (emr-initialize))
#+END_SRC
**** semantic
#+BEGIN_SRC emacs-lisp
  (use-package semantic
    :commands semantic-mode
    :disabled t
    :preface
    (progn
      (add-hook 'prog-mode-hook 'semantic-mode)))
#+END_SRC
** Utility
*** term
#+BEGIN_SRC emacs-lisp
  (use-package term
    :config
    (progn
      (add-hook 'term-mode-hook 'imalison:disable-linum-mode)))
#+END_SRC
*** term-manager
#+BEGIN_SRC emacs-lisp
  (imalison:use-package term-manager
    :defer t
    :preface
    (progn
      (defun imalison:set-escape-char (&rest _args)
        (let (term-escape-char)
         (term-set-escape-char ?\C-x))))
    :config
    (progn
      (advice-add
       'term-manager-default-build-term :after 'imalison:set-escape-char)))
#+END_SRC
*** term-projectile
#+BEGIN_SRC emacs-lisp
  (imalison:use-package term-projectile
    :bind ("C-c 7" . imalison:term-hydra/body)
    :commands (term-projectile-forward term-projectile-backward
                                       term-projectile-default-directory-forward
                                       term-projectile-default-directory-backward
                                       term-projectile-create-new
                                       term-projectile-create-new-default-directory)
    :config
    (progn
      (imalison:prefix-alternatives imalison:term term-projectile-forward
                                    term-projectile-create-new)
      (defhydra imalison:term-hydra-default-directory ()
        "term - default-directory"
        ("n" term-projectile-default-directory-forward)
        ("p" term-projectile-default-directory-backward)
        ("c" term-projectile-create-new-default-directory))

      (defhydra imalison:term-hydra ()
        "term"
        ("n" term-projectile-forward)
        ("p" term-projectile-backward)
        ("c" term-projectile-create-new)
        ("d" imalison:term-hydra-default-directory/body :exit t))))
#+END_SRC
*** crux
crux-reopen-as-root-mode makes it so that any file owned by root will automatically be opened as the root user.
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :demand t
    :bind (("C-c C-s" . crux-sudo-edit))
    :config
    (progn
      (crux-reopen-as-root-mode)))
#+END_SRC
** Communication
*** erc
#+BEGIN_SRC emacs-lisp
  (use-package erc
    :commands erc
    :config
    (progn
      ;; (add-to-list 'erc-modules 'notifications)
      ;; logging:
      (require 'erc-log)
      (setq erc-log-channels-directory "~/Dropbox (Personal)/irclogs")
      (erc-log-enable)
      (use-package erc-colorize) (erc-colorize-mode 1)))
#+END_SRC
*** bitlbee
#+BEGIN_SRC emacs-lisp
  (use-package bitlbee
    :disabled t
    :config
    (progn
      (defvar bitlbee-password "geheim")
      (add-hook 'erc-join-hook 'bitlbee-identify)
      (defun bitlbee-identify ()
        "If we're on the bitlbee server, send the identify command to the
   &bitlbee channel."
        (when (and (string= "localhost" erc-session-server)
                   (string= "&bitlbee" (buffer-name)))
          (erc-message "PRIVMSG" (format "%s identify %s"
                                         (erc-default-target)
                                         bitlbee-password))))))

#+END_SRC
** Other
*** anzu
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :config
    (progn
      (global-anzu-mode +1)

      (custom-set-variables
       '(anzu-mode-lighter "")
       '(anzu-deactivate-region t)
       '(anzu-search-threshold 1000)
       '(anzu-replace-threshold 50)
       '(anzu-replace-to-string-separator " => "))

      (define-key isearch-mode-map [remap isearch-query-replace]
        #'anzu-isearch-query-replace)
      (define-key isearch-mode-map [remap isearch-query-replace-regexp]
        #'anzu-isearch-query-replace-regexp)))
#+END_SRC
*** iedit
I don't use iedit directly, but it is used by [[*emr][emr]] and I need to disable ~iedit-toggle-key-default~ or else a buffer pops up complaing that the key has been bound to something else
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :defer t)
#+END_SRC
*** tramp
#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :commands tramp
    :config
    (setq tramp-default-method "scp"))
#+END_SRC
*** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config
    (progn
      (global-flycheck-mode)
      (use-package flycheck-package
        :config (flycheck-package-setup)))
    :diminish flycheck-mode)
#+END_SRC
*** narrow-indirect
#+BEGIN_SRC emacs-lisp
  (use-package narrow-indirect
    :init
    (progn
      (define-key ctl-x-4-map "nd" 'ni-narrow-to-defun-indirect-other-window)
      (define-key ctl-x-4-map "nn" 'ni-narrow-to-region-indirect-other-window)
      (define-key ctl-x-4-map "np" 'ni-narrow-to-page-indirect-other-window)))
#+END_SRC
*** editorconfig
#+BEGIN_SRC emacs-lisp
    (use-package editorconfig
      :config
      (progn
        (editorconfig-mode 1)))
#+END_SRC
*** dtrt-indent
#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :commands 'dtrt-indent-mode
    :init (add-hook 'prog-mode-hook 'dtrt-indent-mode)
    :config
    (progn
      (setq dtrt-indent-active-mode-line-info " [⟼]")))
#+END_SRC
*** indent-guide
#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :disabled t
    :config
    (progn
      (indent-guide-global-mode -1)
      (setq indent-guide-delay 0.1)))
#+END_SRC
*** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :commands rainbow-delimiters-mode
    :init
    (progn
      (add-hook 'prog-mode-hook (lambda () (rainbow-delimiters-mode t)))))
#+END_SRC
*** company
#+BEGIN_SRC emacs-lisp
(use-package company
    :commands company-mode imalison:company
    :bind (("C-\\" . imalison:company))
    :config
    (progn
      (imalison:prefix-alternatives
       imalison:company company-complete company-yasnippet)
      (setq company-idle-delay .25)
      (global-company-mode)
      (diminish 'company-mode))
    :init
    (add-hook 'prog-mode-hook (lambda () (company-mode t))))
#+END_SRC
*** undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :disabled t ;; this has been getting pretty annoying
    :bind (("C--" . undo-redo)
           ("C-c u" . undo-tree-visualize)
           ("C-c r" . undo-tree-redo))
    :config
    (diminish 'undo-tree-mode)
    :init
    (progn
      ;;(setq undo-tree-visualizer-diff t) ;; This causes performance problems
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)))
#+END_SRC
*** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (progn
      (advice-add 'recentf-cleanup :around 'imalison:shut-up-around)
      (recentf-mode 1)
      (setq recentf-max-menu-items 500)))
#+END_SRC
*** restclient
#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :mode (("\\.restclient\\'" . restclient-mode))
    :config
    (progn
      (use-package company-restclient)))
#+END_SRC
*** key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :preface
    (defun imalison:disable-keychord-around (function &rest args)
      (let ((key-chord-mode-was-enabled (bound-and-true-p key-chord-mode)))
        (when key-chord-mode-was-enabled (key-chord-mode -1))
        (condition-case err (progn (apply function args)) (error))
        (when key-chord-mode-was-enabled (key-chord-mode 1))))
    :config
    (progn
      (advice-add 'key-chord-mode :around 'imalison:shut-up-around)
      (key-chord-mode 1)
      (advice-add 'imalison:avy :around 'imalison:disable-keychord-around)
      (key-chord-define-global "tg" 'imalison:term-hydra/body)
      (key-chord-define-global "pj" 'imalison:projectile-find-file)
      (key-chord-define-global "p[" 'projectile-switch-project)
      (key-chord-define-global "fj" 'imalison:do-ag)
      (key-chord-define-global "jh" 'imalison:avy)))
#+END_SRC
*** nodejs-repl
#+BEGIN_SRC emacs-lisp
  (use-package nodejs-repl
    :commands nodejs-repl)
#+END_SRC
*** calc-mode
#+BEGIN_SRC emacs-lisp
  (use-package calc-mode
    :ensure nil
    :commands calc
    :config
    (progn
      (setq calc-context-sensitive-enter t)))
#+END_SRC
*** helm-spotify
#+BEGIN_SRC emacs-lisp
  (use-package helm-spotify
    :commands helm-spotify)
#+END_SRC
*** jabber
#+BEGIN_SRC emacs-lisp
  (use-package jabber
    :commands jabber-connect
    :config
    (progn
      (setq jabber-alert-presence-hooks nil)
      (defun jabber-message-content-message (from buffer text)
        (when (or jabber-message-alert-same-buffer
                  (not (memq (selected-window) (get-buffer-window-list buffer))))
          (if (jabber-muc-sender-p from)
              (format "%s: %s" (jabber-jid-resource from) text)
            (format "%s: %s" (jabber-jid-displayname from) text))))
      (setq jabber-alert-message-function 'jabber-message-content-message)))
#+END_SRC
*** htmlize
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC
*** calfw
#+BEGIN_SRC emacs-lisp
  (use-package calfw
    :config
    (progn
      (require 'calfw-org)))
#+END_SRC
*** clocker
Not really sure what this is
#+BEGIN_SRC emacs-lisp
  (use-package clocker)
#+END_SRC
*** deft
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :commands deft
    :config
    (progn
      (setq deft-default-extension "org")
      (setq deft-extensions '("org"))
      (setq deft-use-filter-string-for-filename t)
      (setq deft-file-naming-rules '((noslash . "_")
                                     (nospace . "_")
                                     (case-fn . downcase)))
      (setq deft-directory "~/SparkleShare/org/notes")))
#+END_SRC
*** epg
#+BEGIN_SRC emacs-lisp
  (use-package epg
    :after shut-up
    :config
    (shut-up (epa-file-enable)))
#+END_SRC
*** twittering-mode
#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :commands twittering-mode)
#+END_SRC
*** matrix-client
#+BEGIN_SRC emacs-lisp
  (use-package matrix-client
    :disabled t ;; fails to load eieio on startup
    )

#+END_SRC
*** mu4e
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 's)
    (defvar mu4e-elisp-directory
      (s-trim (shell-command-to-string "mu4e_directory"))))
  (use-package mu4e
    :load-path mu4e-elisp-directory
    :ensure nil
    :commands (mu4e mu4e-view-message-with-msgid mu4e-update-index email)
    :bind ("C-c 0" . email)
    :config
    (progn
      (defun email (&optional arg)
        (interactive "P")
        (if (string-equal (persp-name persp-curr) "email")
            (progn (delete-other-windows) (mu4e))
          (progn
            (persp-switch "email")
            (when (or (not (mu4e-running-p)) arg)
              (delete-other-windows) (mu4e)))))
      ;; enable inline images
      (setq mu4e-view-show-images t)
      ;; show images
      (setq mu4e-show-images t)
      ;; Try to display html as text
      (setq mu4e-view-prefer-html nil)

      (setq mu4e-html2text-command "html2text -width 80 -nobs -utf8")

      ;; use imagemagick, if available
      (when (fboundp 'imagemagick-register-types)
           (imagemagick-register-types))
      (setq mail-user-agent 'mu4e-user-agent)
      (require 'org-mu4e)
      (setq mu4e-compose-complete-only-after nil)
      (setq mu4e-maildir "~/Mail")

      (setq mu4e-drafts-folder "/[Gmail].Drafts")
      (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
      (setq mu4e-trash-folder  "/[Gmail].Trash")

      (setq mu4e-sent-messages-behavior 'delete)
      (setq mu4e-headers-skip-duplicates t)
      (setq mu4e-update-interval (* 60 20))
      (setq message-kill-buffer-on-exit t)
      (setq mail-user-agent 'mu4e-user-agent) ;; make mu4e the default mail client

      ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
      (setq mu4e-sent-messages-behavior 'delete)

      ;; allow for updating mail using 'U' in the main view:
      (setq mu4e-get-mail-command "timeout 60 offlineimap")

      (add-hook 'mu4e-compose-mode-hook
                (defun my-do-compose-stuff () (flyspell-mode)))

      (add-to-list 'mu4e-headers-actions '("view in browser" . mu4e-action-view-in-browser))
      (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser))

      (defun mu4e-view (msg headersbuf)
        "Display the message MSG in a new buffer, and keep in sync with HDRSBUF.
  'In sync' here means that moving to the next/previous message in
  the the message view affects HDRSBUF, as does marking etc.

  As a side-effect, a message that is being viewed loses its 'unread'
  marking if it still had that."
        (let* ((embedded ;; is it as an embedded msg (ie. message/rfc822 att)?
                (when (gethash (mu4e-message-field msg :path)
                               mu4e~path-parent-docid-map) t))
               (buf
                (if embedded
                    (mu4e~view-embedded-winbuf)
                  (get-buffer-create mu4e~view-buffer-name))))
          ;; note: mu4e~view-mark-as-read will pseudo-recursively call mu4e-view again
          ;; by triggering mu4e~view again as it marks the message as read
          (with-current-buffer buf
            (switch-to-buffer buf)
            (setq mu4e~view-msg msg)
            ;;(or embedded (not (mu4e~view-mark-as-read msg)))
            (when (or (mu4e~view-mark-as-read msg) t)
              (let ((inhibit-read-only t))
                (erase-buffer)
                (mu4e~delete-all-overlays)
                (insert (mu4e-view-message-text msg))
                (goto-char (point-min))
                (mu4e~fontify-cited)
                (mu4e~fontify-signature)
                (mu4e~view-make-urls-clickable)
                (mu4e~view-show-images-maybe msg)
                (setq
                 mu4e~view-buffer buf
                 mu4e~view-headers-buffer headersbuf)
                (when embedded (local-set-key "q" 'kill-buffer-and-window))
                (mu4e-view-mode))))))

      (require 'smtpmail)

      ;; alternatively, for emacs-24 you can use:
      (setq message-send-mail-function 'smtpmail-send-it
            smtpmail-stream-type 'starttls
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587)))

#+END_SRC
*** gmail-message-mode
This is useful with server mode when editing gmail messages. I think that it is not currently working, or it may need to be manually enabled.
#+BEGIN_SRC emacs-lisp
  (use-package gmail-message-mode)
#+END_SRC
*** alert
#+BEGIN_SRC emacs-lisp
  (use-package alert
    :config
    (progn
      (defun alert-notifier-notify (info)
        (if alert-notifier-command
            (let ((args
                   (list "-title"   (alert-encode-string (plist-get info :title))
                         "-activate" "org.gnu.Emacs"
                         "-message" (alert-encode-string (plist-get info :message))
                         "-execute" (format "\"%s\"" (switch-to-buffer-command (plist-get info :buffer))))))
              (apply #'call-process alert-notifier-command nil nil nil args))
          (alert-message-notify info)))

      (defun switch-to-buffer-command (buffer-name)
        (emacsclient-command (format "(switch-to-buffer \\\"%s\\\")" buffer-name)))

      (defun emacsclient-command (command)
        (format "emacsclient --server-file='%s' -e '%s'" server-name command))

      (setq alert-default-style 'notifier)))
#+END_SRC
*** sauron
#+BEGIN_SRC emacs-lisp
  (use-package sauron
    :defer 5
    :commands (sauron-start sauron-start-hidden)
    :init
    (progn
      (when (eq system-type 'darwin)
        (setq sauron-modules '(sauron-erc sauron-org sauron-notifications
                                          sauron-twittering sauron-jabber sauron-identica))
        (defun sauron-dbus-start ()
          nil)
        (makunbound 'dbus-path-emacs)))
    :config
    (progn
      (sauron-start-hidden)
      ;; This should really check (featurep 'dbus) but for some reason
      ;; this is always true even if support is not there.
      (setq sauron-prio-sauron-started 2)
      (setq sauron-min-priority 3)
      ;; (setq sauron-dbus-cookie t) ;; linux only?
      (setq sauron-separate-frame nil)
      (setq sauron-nick-insensitivity 1)
      (defun sauron:jabber-notify (origin priority message &optional properties)
        (funcall notify-function "gtalk" message))
      (defun sauron:erc-notify (origin priority message &optional properties)
        (let ((event (plist-get properties :event)))
          (funcall notify-function "IRC" message)))
      (defun sauron:mu4e-notify (origin priority message &optional properties)
        nil)
      (defun sauron:dbus-notify (origin priority message &optional properties)
        (funcall notify-function "GMail" message))
      (defun sauron:dispatch-notify (origin priority message &optional properties)
        (let ((handler (cond ((string= origin "erc") 'sauron:erc-notify)
                             ((string= origin "jabber") 'sauron:jabber-notify)
                             ((string= origin "mu4e") 'sauron:mu4e-notify)
                             ((string= origin "dbus") 'sauron:dbus-notify)
                             (t (lambda (&rest r) nil)))))
          (funcall handler origin priority message properties)))
      ;; Prefering alert.el for now ;; (add-hook 'sauron-event-added-functions 'sauron:dispatch-notify)
      (sauron-start-hidden)
      (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)))

#+END_SRC
*** screenshot
#+BEGIN_SRC emacs-lisp
  (use-package screenshot)
#+END_SRC
*** floobits
#+BEGIN_SRC emacs-lisp
  (use-package floobits)
#+END_SRC
*** wsd-mode
#+BEGIN_SRC emacs-lisp
  (use-package wsd-mode
    :commands (wsd-mode))
#+END_SRC
*** libmpdee
#+BEGIN_SRC emacs-lisp
  (use-package libmpdee)
#+END_SRC
*** flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :disabled t                           ; kind of annoying
    :preface (setq flyspell-issue-welcome-flag nil)
    :config
    (progn
      (diminish 'flyspell-mode)
      (bind-key "M-s" 'flyspell-correct-word-before-point flyspell-mode-map)
      (unbind-key "C-;" flyspell-mode-map)
      (defun flyspell-emacs-popup-textual (event poss word)
        "A textual flyspell popup menu."
        (let* ((corrects (if flyspell-sort-corrections
                             (sort (car (cdr (cdr poss))) 'string<)
                           (car (cdr (cdr poss)))))
               (cor-menu (if (consp corrects)
                             (mapcar (lambda (correct)
                                       (list correct correct))
                                     corrects)
                           '()))
               (affix (car (cdr (cdr (cdr poss)))))
               show-affix-info
               (base-menu  (let ((save (if (and (consp affix) show-affix-info)
                                           (list
                                            (list (concat "Save affix: "
                                                          (car affix))
                                                  'save)
                                            '("Accept (session)" session)
                                            '("Accept (buffer)" buffer))
                                         '(("Save word" save)
                                           ("Accept (session)" session)
                                           ("Accept (buffer)" buffer)))))
                             (if (consp cor-menu)
                                 (append cor-menu (cons "" save))
                               save)))
               (menu (mapcar
                      (lambda (arg) (if (consp arg) (car arg) arg))
                      base-menu)))
          (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
      (fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)))
#+END_SRC
*** web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.tmpl\\'" . web-mode)
           ("\\.cql\\'" . web-mode))
    :config
    (progn
      (defvar-setq web-mode-content-types-alist
        '(("gtl" . "\\.tmpl\\'")
          ("gtl" . "\\.cql\\'")))))

#+END_SRC
*** helm-themes
#+BEGIN_SRC emacs-lisp
  (use-package helm-themes)
#+END_SRC
*** helm-swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :bind ("C-S-s" . helm-swoop)
    :commands helm-swoop)
#+END_SRC
*** perspective
#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :demand t
    :config
    (progn
      (persp-mode)
      (defun persp-get-perspectives-for-buffer (buffer)
        "Get the names of all of the perspectives of which `buffer` is a member."
        (cl-loop for perspective being the hash-value of perspectives-hash
                 if (member buffer (persp-buffers perspective))
                 collect (persp-name perspective)))

      (defun persp-pick-perspective-by-buffer (buffer)
        "Select a buffer and go to the perspective to which that buffer
    belongs. If the buffer belongs to more than one perspective
    completion will be used to pick the perspective to switch to.
    Switch the focus to the window in which said buffer is displayed
    if such a window exists. Otherwise display the buffer in whatever
    window is active in the perspective."
        (interactive (list (funcall persp-interactive-completion-function
                                    "Buffer: " (mapcar 'buffer-name (buffer-list)))))
        (let* ((perspectives (persp-get-perspectives-for-buffer (get-buffer buffer)))
               (perspective (if (> (length perspectives) 1)
                                (funcall persp-interactive-completion-function
                                         (format "Select the perspective in which you would like to visit %s."
                                                 buffer)
                                         perspectives)
                              (car perspectives))))
          (if (string= (persp-name persp-curr) perspective)
              ;; This allows the opening of a single buffer in more than one window
              ;; in a single perspective.
              (switch-to-buffer buffer)
            (progn
              (persp-switch perspective)
              (if (get-buffer-window buffer)
                  (set-frame-selected-window nil (get-buffer-window buffer))
                (switch-to-buffer buffer))))))

      (defun persp-mode-switch-buffers (arg)
        (interactive "P")
        (if arg (call-interactively 'ido-switch-buffer)
          (call-interactively 'persp-pick-perspective-by-buffer)))

      (define-key persp-mode-map (kbd "C-x b") 'persp-mode-switch-buffers))
    :bind ("C-c 9" . persp-switch))
#+END_SRC
*** smex
#+BEGIN_SRC emacs-lisp
  (use-package smex
    ;; Using helm-M-x instead
    :disabled t
    :commands smex
    ;; This is here because smex feels like part of ido
    :bind ("M-x" . smex))
#+END_SRC
*** ido
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :if (and (boundp 'use-ido) use-ido)
    :commands ido-mode
    :config
    (progn
      (ido-mode 1)
      (setq ido-auto-merge-work-directories-length -1)
      (setq ido-use-filename-at-point nil)
      (setq ido-create-new-buffer 'always)
      (ido-everywhere 1)
      (setq ido-enable-flex-matching t)
      (use-package flx)
      (use-package flx-ido
        :commands flx-ido-mode
        :init (flx-ido-mode 1)
        :config
        (progn
          ;; disable ido faces to see flx highlights.
          ;; This makes flx-ido much faster.
          (setq gc-cons-threshold 20000000)
          (setq ido-use-faces nil)))
      (use-package ido-ubiquitous
        :disabled t
        :commands (ido-ubiquitous-mode))
      (use-package ido-vertical-mode
        :config
        (progn
          (ido-vertical-mode 1)
          (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)))
      (use-package flx-ido)))
#+END_SRC
*** java
#+BEGIN_SRC emacs-lisp
  (add-hook 'java-mode-hook
            (lambda ()
              (setq c-basic-offset 4
                    tab-width 4
                    indent-tabs-mode t)))

#+END_SRC
*** android-mode
#+BEGIN_SRC emacs-lisp
  (use-package android-mode
    :after s
    :config
    (progn
      (setq android-mode-sdk-dir
            (s-trim (shell-command-to-string "android_sdk_directory")))))
#+END_SRC
*** gradle-mode
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode)
#+END_SRC
*** json-mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'"
    :init
    (add-hook 'json-mode-hook
              (lambda ()
                (setq indent-tabs-mode nil)
                (setq js-indent-level 4))))
#+END_SRC
*** jq-mode
#+BEGIN_SRC emacs-lisp
  (use-package jq-mode
    :mode "\\.jq\\'")
#+END_SRC
*** jsx-mode
#+BEGIN_SRC emacs-lisp
  (use-package jsx-mode
    :mode "\\.jsx\\'")
#+END_SRC
*** css
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'css-mode
    '(define-key css-mode-map (kbd "C-c b") 'web-beautify-css))
#+END_SRC
*** robe
#+BEGIN_SRC emacs-lisp
  (use-package robe
    :commands robe-mode
    :init
    (progn (add-hook 'ruby-mode-hook 'robe-mode)))
#+END_SRC
*** rinari
#+BEGIN_SRC emacs-lisp
  (use-package rinari
    :after ruby-mode)
#+END_SRC
*** helm-gtags
#+BEGIN_SRC emacs-lisp
  (use-package helm-gtags
    :disabled t
    :config (custom-set-variables
             '(helm-gtags-path-style 'relative)
             '(helm-gtags-ignore-case t)
             '(helm-gtags-auto-update t))
    :bind
    (("M-t" . helm-gtags-find-tag)
     ("M-r" . helm-gtags-find-rtag)
     ("M-s" . helm-gtags-find-symbol)
     ("C-c <" . helm-gtags-previous-history)
     ("C-c >" . helm-gtags-next-history))
    :init
    (progn
      ;;; Enable helm-gtags-mode
      (add-hook 'c-mode-hook 'helm-gtags-mode)
      (add-hook 'c++-mode-hook 'helm-gtags-mode)
      (add-hook 'asm-mode-hook 'helm-gtags-mode)))
#+END_SRC
*** tex
#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :preface
    (progn
      (defun guess-TeX-master (filename)
        "Guess the master file for FILENAME from currently open .tex files."
        (let ((candidate nil)
              (filename (file-name-nondirectory filename)))
          (save-excursion
            (dolist (buffer (buffer-list))
              (with-current-buffer buffer
                (let ((name (buffer-name))
                      (file buffer-file-name))
                  (if (and file (string-match "\\.tex$" file))
                      (progn
                        (goto-char (point-min))
                        (if (re-search-forward
                             (concat "\\\\input{" filename "}") nil t)
                            (setq candidate file))
                        (if (re-search-forward
                             "\\\\include{" (file-name-sans-extension filename) "}"
                             nil t)
                            (setq candidate file))))))))
          (if candidate
              (message "TeX master document: %s" (file-name-nondirectory candidate)))
          candidate))

      (defun set-TeX-master ()
        (setq TeX-master (guess-TeX-master (buffer-file-name)))))
    :commands TeX-mode
    :config
    (progn
      (add-hook 'TeX-mode-hook 'set-TeX-master)
      (unbind-key "C-j" TeX-mode-map)
      (setq TeX-auto-save t)
      (setq TeX-parse-self t)
      (setq TeX-save-query nil)
      (setq TeX-PDF-mode t)
      (TeX-global-PDF-mode t)
      (setq-default TeX-master nil)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
#+END_SRC
*** latex
#+BEGIN_SRC emacs-lisp
  (use-package latex
    :ensure auctex
    :after tex
    :config
    (progn
      (unbind-key "C-j" LaTeX-mode-map)))
#+END_SRC
*** yaml-mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yaml\\'" . yaml-mode)
           ("\\.yml\\'" . yaml-mode)))
#+END_SRC
*** sgml-mode
#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    ;; :bind ("C-c b" . web-beautify-html) TODO: mode specific, change binding
    :commands sgml-mode)
#+END_SRC
*** gitconfig-mode
#+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode
    :mode "\\.?gitconfig\\'")
#+END_SRC
*** evil
#+BEGIN_SRC emacs-lisp
  (use-package evil :commands (evil-mode))
#+END_SRC
*** thrift
#+BEGIN_SRC emacs-lisp
  (use-package thrift
    :commands thrift-mode
    :mode (("\\.thrift\\'" . thrift-mode)))
#+END_SRC
*** markdown-mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :init
    (progn
      (add-hook 'markdown-mode-hook 'imalison:disable-linum-mode)))
#+END_SRC
*** hackernews
#+BEGIN_SRC emacs-lisp
  (use-package hackernews :commands hackernews)
#+END_SRC
* Keybindings
This ensures that C-x C-c will always kill emacs, even if we are running in server mode.
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-c" 'kill-emacs)
#+END_SRC
imenu is the best. This should be a default binding.
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-c" 'kill-emacs)
  (bind-key "C--" 'undo)
#+END_SRC
Go the other way when you use capital O.
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x O" (lambda () (interactive) (other-window -1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bind-key "M-q" 'fill-or-unfill-paragraph)
  (bind-key "C-c SPC" 'imalison:mark-ring)
  (bind-key "C-x p" 'pop-to-mark-command)
  (setq set-mark-command-repeat-pop t)
  (bind-key "C-x C-b" 'buffer-menu)
  (bind-key "C-x C-r" (lambda () (interactive) (revert-buffer t t)))
  (bind-key "C-x w" 'whitespace-mode)
  (bind-key "M-n" 'forward-paragraph)
  (bind-key "M-p" 'backward-paragraph)
  (bind-key "C-M-<backspace>" 'backward-kill-sexp)
  (bind-key "s-<return>" 'toggle-frame-fullscreen)
  (bind-key "M-|" 'imalison:shell-command-on-region)
  (bind-key "C-x 9" 'previous-buffer)
  (bind-key "s-v" 'clipboard-yank)

  (fset 'global-set-key-to-use-package
        (lambda (&optional arg) "Keyboard macro." (interactive "p")
          (kmacro-exec-ring-item
           (quote ([1 67108896 19 100 6 23 40 19 41 return
                      backspace 32 46 6 4] 0 "%d")) arg)))
#+END_SRC
** OSX
#+BEGIN_SRC emacs-lisp
  (when (equal system-type 'darwin)
    (setq mac-option-modifier 'meta)
    (setq mac-command-modifier 'super))
#+END_SRC
* Appearance
** Config
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
  (blink-cursor-mode -1)
#+END_SRC
** Themes
Ensure all themes that I use are installed:
#+BEGIN_SRC emacs-lisp
  (defvar-setq packages-appearance
    '(monokai-theme solarized-theme zenburn-theme base16-theme molokai-theme
      tango-2-theme gotham-theme sublime-themes rainbow-delimiters waher-theme
      ample-theme material-theme zerodark-theme color-theme-modern leuven-theme
      spacemacs-theme gruvbox-theme forest-blue-theme))

  (ensure-packages-installed packages-appearance)
#+END_SRC
** spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    :ensure spaceline
    :config
    (progn
      (setq powerline-default-separator (random-choice '(butt slant wave)))
      (setq spaceline-workspace-numbers-unicode t
            spaceline-window-numbers-unicode t)
      (if (display-graphic-p)
          (setq-default powerline-default-separator 'wave)
        (setq-default powerline-default-separator 'utf-8))
      (spaceline-define-segment imalison:muni
        "Display the number of minutes until the next muni train comes"
        (format "🚇%s" (imalison:get-cached-muni-time))
        :when active)
      (setq powerline-height 25)
      (spaceline-helm-mode)
      (spaceline-spacemacs-theme)))
#+END_SRC
** window-number
#+BEGIN_SRC emacs-lisp
  (use-package window-number
    :defer t)
#+END_SRC
** Whitespace Setup

Make whitespace-mode use just basic coloring:
#+BEGIN_SRC emacs-lisp
  (setq whitespace-style
        '(spaces tabs newline space-mark tab-mark newline-mark))
#+END_SRC

Set the character used to represent spaces to ·, and the character used for tabs to be ▷.
#+BEGIN_SRC emacs-lisp
  (setq whitespace-display-mappings
        '((space-mark 32 [183] [46])
          (tab-mark 9 [9655 9] [92 9])))
#+END_SRC

** Colorize Compliation Buffers
   This automatically applies ansi-color interpretation of terminal escape sequences to compilation buffers
#+BEGIN_SRC emacs-lisp
  (defun colorize-compilation-buffer ()
    (read-only-mode)
    (ansi-color-apply-on-region (point-min) (point-max))
    (read-only-mode))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

** TODO Finish making the following litarate
#+BEGIN_SRC emacs-lisp

  ;; =============================================================================
  ;;                                                                        Themes
  ;; =============================================================================

  ;; These can be overriden in custom-before.el
  (defvar imalison:light-theme 'solarized-light)
  (defvar imalison:dark-theme 'material)
  (use-package theme-changer
    :disabled t
    :config
    (progn
      (destructuring-bind (latitude longitude)
          (imalison:get-lat-long)
        (setq calendar-latitude latitude)
        (setq calendar-longitude longitude))))

  (defun imalison:set-font-height ()
    (interactive)
    (let ((new-height (read-face-attribute 'default :height (selected-frame))))
      (set-face-attribute 'default nil :height new-height)))

  (defvar imalison:linum-format)

  (make-variable-buffer-local 'imalison:linum-format)
  (defun imalison:linum-before-numbering-hook ()
    (setq imalison:linum-format
          (concat "%" (number-to-string
                       (max (length
                             (number-to-string
                              (count-lines (point-min) (point-max)))) 3)) "d")))

  (defun imalison:format-linum (line-text)
    (propertize (format imalison:linum-format line-text) 'face 'linum))

  (defun imalison:remove-fringe-and-hl-line-mode (&rest _stuff)
    (interactive)
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    ;; (set-fringe-mode 0) ;; Lets reenable fringes. They seem useful
    (defvar-setq linum-format 'imalison:format-linum)
    (add-hook 'linum-before-numbering-hook 'imalison:linum-before-numbering-hook)
    (setq left-margin-width 0)
    (defvar-setq hl-line-mode nil))

  (defun imalison:after-load-theme (&rest _args)
    (when (fboundp 'powerline-reset)
      (powerline-reset))
    (set-face-background 'fringe (face-background 'default))
    (imalison:restore-ansi-term-color-vector))

  (when t
    (if
        (advice-add 'load-theme :after #'imalison:after-load-theme)
      (defadvice load-theme (after name activate)
        (imalison:after-load-theme))))

  (when (file-exists-p custom-after-file) (load custom-after-file))

  (defvar imalison:ansi-term-color-vector ansi-term-color-vector)

  (defun imalison:ansi-term-color-vector-broken? ()
      (--some (or (eq it 'unspecified) (not (symbolp it)))
              (append ansi-term-color-vector nil)))

  (defun imalison:restore-ansi-term-color-vector (&optional force)
    (when (or force (imalison:ansi-term-color-vector-broken?))
      (setq ansi-term-color-vector imalison:ansi-term-color-vector)))

  (defun imalison:appearance (&optional frame)
    (interactive)
    (if (display-graphic-p)
        (progn
          (set-face-attribute 'default nil :font "Source Code Pro")
          (set-face-attribute 'default nil :weight 'semi-bold)
          (set-face-attribute 'default nil :height 135))
      (progn
        (load-theme 'source-code-pro t)
        (message "not setting font")))
    (load-theme imalison:dark-theme t)
    (imalison:remove-fringe-and-hl-line-mode))

  ;; This is needed because you can't set the font or theme at daemon start-up.
  ;; (when (display-graphic-p) (imalison:appearance))
  (add-hook 'after-init-hook 'imalison:appearance)
  (add-hook 'after-make-frame-functions 'imalison:appearance)
  (remove-hook 'after-make-frame-functions 'imalison:appearance)
#+END_SRC
